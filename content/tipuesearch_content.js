var tipuesearch = {"pages": [{'title': 'About', 'text': 'Repo:  https://github.com/mdecycu/cp2025_hw \xa0(請修改為您的作業倉儲) \n Site:  https://mdecycu.github.io/cp2025_hw \xa0(請修改為您的作業網站) \n 可攜程式套件: \n portable_2026.7z \xa0(387MB) \n 解開壓縮後，雙點擊\xa0start_miniconda3.bat 啟動可攜系統，雙點擊 stop.bat 關閉可攜系統。 \n 可攜系統啟動後，在命令列執行 conda activate y:\\envs\\cmsimde 可進入能執行 CMSiMDE 的環境。 \n 若希望可攜系統啟動直接進入 cmsimde 環境，可將 start_miniconda3.bat 檔案中第 98 行: call "%CONDA_ROOT%\\Scripts\\activate.bat" %ENV_NAME% 更換為 call "%CONDA_ROOT%\\Scripts\\activate.bat" %Disk%:\\envs\\cmsimde \n', 'tags': '', 'url': 'About.html'}, {'title': 'Homework', 'text': 'HW1: \n 請將程式碼存放在個人作業倉儲中的 python 目錄後，利用程式連結完成下列任務: \n around1 ,  around2 ,  around3 ,  around4 \n HW2: \n 請修改  Brython_robot  程式，讓機器人可以採水平巡邏方式，走過每一個區域。 \n 請修改  Brython_robot  程式，讓機器人可以採上下垂直巡邏方式，走過每一個區域。 \n HW3: \n 請修改\xa0 brython_robot4_ex1.py  程式，讓機器人可以與 機器人收割程式 的水平採收方式相同。 \n 請修改\xa0 brython_robot4_ex1.py  程式，讓機器人可以與 機器人收割程式 的上下垂直採收方式相同。 \n HW4: \n 請修改\xa0 brython_robot4_ex1.py  程式，讓機器人可以與 機器人收割程式 的採收與播種方式相同。 \n 請修改 Pyodide  機器人自由行 程式，讓機器人可以採水平巡邏方式，走過每一個區域。 \n 請修改 Pyodide  機器人自由行2 程式，讓機器人可以採上下垂直巡邏方式，走過每一個區域。 \n \n \n', 'tags': '', 'url': 'Homework.html'}, {'title': 'HW0', 'text': '自行建立 Github 帳號 -\xa0 https://github.com/signup \xa0 \n 取得個人的作業倉儲 - 透過\xa0 https://classroom.github.com \xa0 \n 設定 Github Pages - 利用作業倉儲建立作業網站 \n 可以直接在瀏覽器上透過 Reeborg、Brython 或 Pyodide 頁面，學習 Python 語法 \n 利用 Codespaces 維護作業內容 -\xa0 https://github.com/codespaces \xa0(免費帳號每月可以使用 120 core小時 + 15GB 儲存， 學生認證 後可使用 180 core小時 + 20GB 儲存) \n https://docs.github.com/en/billing/managing-billing-for-your-products/about-billing-for-github-codespaces \xa0 \n 利用可攜程式系統維護作業內容 \n portable_2026.7z \xa0(387MB) - 在隨身碟或個人電腦上解開壓縮後使用 \n 解開壓縮後，雙點擊\xa0start_miniconda3.bat 啟動可攜系統，雙點擊 stop.bat 關閉可攜系統。 \n 可攜系統啟動後，在命令列執行 conda activate y:\\envs\\cmsimde 可進入能執行 CMSiMDE 的環境。 \n 若希望可攜系統啟動直接進入 cmsimde 環境，可將 start_miniconda3.bat 檔案中第 98 行: call "%CONDA_ROOT%\\Scripts\\activate.bat" %ENV_NAME% 更換為 call "%CONDA_ROOT%\\Scripts\\activate.bat" %Disk%:\\envs\\cmsimde \n Python 程式教材 \n 使用 Reeborg 學習 Python:\xa0 https://mde.tw/cp2025/content/Reeborg.html \xa0 \n 使用 Brython 學習 Python:\xa0 https://mde.tw/cp2025/content/Brython.html \xa0 \n 使用 Pyodide 學習 Python:\xa0 https://mde.tw/cp2025/content/Pyodide.html \xa0 \n 機械設計工程師學習 Python 做甚麼? - 請自行 利用 ChatGPT 提問 \n \xa0 \xa0\xa0 \n \n \n \n', 'tags': '', 'url': 'HW0.html'}, {'title': 'HW1', 'text': '請將程式碼存放在個人作業倉儲中的 python 目錄後，利用程式連結完成下列任務: \n around1 ,  around2 ,  around3 ,  around4 \n \n', 'tags': '', 'url': 'HW1.html'}, {'title': 'HW2', 'text': '請修改  Brython_robot  程式，讓機器人可以採水平巡邏方式，走過每一個區域。 \n 請修改  Brython_robot  程式，讓機器人可以採上下垂直巡邏方式，走過每一個區域。 \n \n \n', 'tags': '', 'url': 'HW2.html'}, {'title': 'HW3', 'text': '請修改\xa0 brython_robot4_ex1.py  程式，讓機器人可以與 機器人收割程式 的水平採收方式相同。 \n 請修改\xa0 brython_robot4_ex1.py  程式，讓機器人可以與 機器人收割程式 的上下垂直採收方式相同。 \n \n', 'tags': '', 'url': 'HW3.html'}, {'title': 'HW4', 'text': '請修改\xa0 brython_robot4_ex1.py  程式，讓機器人可以與 機器人收割程式 的採收與播種方式相同。 \n 請修改 Pyodide  機器人自由行 程式，讓機器人可以採水平巡邏方式，走過每一個區域。 \n 請修改 Pyodide  機器人自由行2 程式，讓機器人可以採上下垂直巡邏方式，走過每一個區域。 \n', 'tags': '', 'url': 'HW4.html'}, {'title': 'Brython', 'text': '1 add to 100 機器人巡邏 自由行 \n  導入 brython 程式庫  \n \n \n \n \n  啟動 Brython  \n \n \n \n  導入 FileSaver 與 filereader  \n \n \n \n \n  導入 ace  \n \n \n \n \n \n \n  導入 gearUtils-0.9.js Cango 齒輪繪圖程式庫  \n \n \n \n \n \n \n  請注意, 這裡使用 Javascript 將 localStorage["kw_py_src1"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱 \n \n \n \n  累加程式開始  \n \n  累加程式結束     機器人巡邏程式開始  \n \n  機器人巡邏程式結束  \n  機器人自由行程式開始  \n \n \n \n  機器人自由行程式結束  \n  add 1 to 100 開始  \n \n \n  add 1 to 100 結束 \n  editor1 開始  \n  用來顯示程式碼的 editor 區域  \n \n  以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合  \n  存擋表單開始  \n Filename:  .py   \n  存擋表單結束  \n \n  執行與清除按鈕開始  \n Run   Output   清除輸出區 清除繪圖區 Reload \n  執行與清除按鈕結束  \n \n  程式執行 ouput 區  \n \n  Brython 程式執行的結果, 都以 brython_div1 作為切入位置  \n \n  editor1 結束   ##########################################  \n 從 1 累加到 100 part2: \n 1 add to 100 cango_three_gears BSnake AI Tetris \n  請注意, 這裡使用 Javascript 將 localStorage["kw_py_src2"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱 \n \n \n \n  add 1 to 100 part2 開始  \n \n \n  add 1 to 100 part2 結束 \n  editor2 開始  \n  用來顯示程式碼的 editor 區域  \n \n  以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合  \n  存擋表單開始  \n Filename:  .py   \n  存擋表單結束  \n \n  執行與清除按鈕開始  \n Run   Output   清除輸出區 清除繪圖區 Reload \n  執行與清除按鈕結束  \n \n  程式執行 ouput 區  \n \n  Brython 程式執行的結果, 都以 brython_div1 作為切入位置  \n \n  editor2 結束  \n \n', 'tags': '', 'url': 'Brython.html'}, {'title': 'Brython_ex', 'text': '機器人自由行 \n Can we bring pythonpad into this page?\xa0 https://pythonpad.github.io/docs/manual.html \xa0 \n from browser import document, html, timer\n \ncanvas = html.CANVAS(width=400, height=400)\nbrython_div = document["brython_div1"]\nbrython_div <= canvas\nctx = canvas.getContext("2d")\n \ndef draw_grid():\n    ctx.clearRect(0, 0, 400, 400)\n    ctx.strokeStyle = "#ccc"\n    ctx.lineWidth = 1\n    for i in range(0, 401, 40):\n        ctx.beginPath()\n        ctx.moveTo(i, 0)\n        ctx.lineTo(i, 400)\n        ctx.stroke()\n        ctx.beginPath()\n        ctx.moveTo(0, i)\n        ctx.lineTo(400, i)\n        ctx.stroke()\n    \n    # 畫出邊界\n    ctx.strokeStyle = "black"\n    ctx.lineWidth = 2\n    ctx.strokeRect(0, 0, 400, 400)\n\ndef draw_robot(x, y):\n    draw_grid()\n    ctx.fillStyle = "blue"\n    ctx.beginPath()\n    ctx.arc(x * 40 + 20, y * 40 + 20, 15, 0, 6.28)\n    ctx.fill()\n\nx, y = 0, 0\ndef move():\n    global x\n    x = (x + 1) % 10\n    draw_robot(x, y)\n\ndraw_grid()\ntimer.set_interval(move, 500) \n 以下程式, 按 j 隨箭頭方向前進, 按下 i 則左轉 \n from browser import document, html, bind\n\ncanvas = html.CANVAS(width=400, height=400)\nbrython_div = document["brython_div1"]\nbrython_div <= canvas\nctx = canvas.getContext("2d")\n\ncols, rows = 10, 10\ncell = 40\n\n# 上、右、下、左\ndirections = [(0, -1), (1, 0), (0, 1), (-1, 0)]\n\nrobot = {\n    "x": 5,\n    "y": 5,\n    "dir": 0  # 初始朝向上\n}\n\ndef draw_grid():\n    ctx.clearRect(0, 0, 400, 400)\n    ctx.strokeStyle = "#ccc"\n    ctx.lineWidth = 1\n    for i in range(0, 401, cell):\n        ctx.beginPath()\n        ctx.moveTo(i, 0)\n        ctx.lineTo(i, 400)\n        ctx.stroke()\n        ctx.beginPath()\n        ctx.moveTo(0, i)\n        ctx.lineTo(400, i)\n        ctx.stroke()\n    ctx.strokeStyle = "black"\n    ctx.lineWidth = 2\n    ctx.strokeRect(0, 0, 400, 400)\n\ndef draw_robot():\n    draw_grid()\n    cx = robot["x"] * cell + cell // 2\n    cy = robot["y"] * cell + cell // 2\n    size = 15\n    d = robot["dir"]\n\n    ctx.fillStyle = "blue"\n    ctx.beginPath()\n    if d == 0:  # 上\n        ctx.moveTo(cx, cy - size)\n        ctx.lineTo(cx - size, cy + size)\n        ctx.lineTo(cx + size, cy + size)\n    elif d == 1:  # 右\n        ctx.moveTo(cx + size, cy)\n        ctx.lineTo(cx - size, cy - size)\n        ctx.lineTo(cx - size, cy + size)\n    elif d == 2:  # 下\n        ctx.moveTo(cx, cy + size)\n        ctx.lineTo(cx - size, cy - size)\n        ctx.lineTo(cx + size, cy - size)\n    elif d == 3:  # 左\n        ctx.moveTo(cx - size, cy)\n        ctx.lineTo(cx + size, cy - size)\n        ctx.lineTo(cx + size, cy + size)\n    ctx.closePath()\n    ctx.fill()\n\n@bind(document, "keydown")\ndef on_key(e):\n    key = e.key.lower()\n    if key == "i":\n        robot["dir"] = (robot["dir"] - 1) % 4  # 左轉\n    elif key == "j":\n        dx, dy = directions[robot["dir"]]\n        nx = robot["x"] + dx\n        ny = robot["y"] + dy\n        if 0 <= nx < cols and 0 <= ny < rows:\n            robot["x"] = nx\n            robot["y"] = ny\n    draw_robot()\n\ndraw_robot() \n Optimization: \n 題目: 一位製造商想設計一個開口式的盒子，其底部為長方形，寬為 x、長為 y，且總表面積為 80 平方公分。 請問要使盒子的體積達到最大，應該選用哪些尺寸？ \n 直接利用 Python 以  Differential Evoluation  運算:\xa0 de_volume_max.py \n 參考:\xa0 \n de_volume_max.c \n 也可以採網頁前端使用 Brython，後端採 Python 執行運算後將資料傳回網頁:\xa0 brython_w_flask.7z \n', 'tags': '', 'url': 'Brython_ex.html'}, {'title': 'Ref', 'text': '', 'tags': '', 'url': 'Ref.html'}, {'title': 'Reeborg', 'text': 'https://mde.tw/cp2025/reeborg?lang=en&mode=python&menu=worlds/menus/select_collection_en.json&name=Alone&url=worlds/tutorial_en/harvest1.json&editor=python/harvest1.py \n https://mde.tw/cp2025/reeborg?lang=en&mode=python&menu=worlds/menus/select_collection_en.json&name=Alone&url=worlds/tutorial_en/harvest1.json&editor=python/harvest1_east_west.py \xa0 \n \n https://mde.tw/reeborg \n https://github.com/mdecycu/cs101 \n https://reeborg.ca/docs/en/python/index.html \n https://aroberge.github.io/reeborg-api/ \n if using local static port 9442: \n Reeborg \n For Github Pages: \n Reeborg \n \n', 'tags': '', 'url': 'Reeborg.html'}, {'title': 'ex1', 'text': 'https://mde.tw/cp2025/reeborg?lang=en&mode=python&menu=worlds/menus/select_collection_en.json&name=Alone&url=worlds/tutorial_en/harvest1.json&editor=python/harvest1.py \xa0是已知的機器人採收紅蘿蔔的程式，經由以下與 Copilot 的對話，希望透過 Python Class 的編寫解決特定範圍農作物採收的程式。 \n 問句: \n 以下是 Reeborg 一個用來採收紅蘿蔔的程式, 目前位於 (3,3) 到 (8,8) 的區域中各座標點, 各有一個紅羅蔔等待採收, 現在想要建立一個 harvest() class, 可以利用 (3,3), (8,8)作為標定有農作物必須採收的兩個區域對角點座標, 而程式可以利用此一 harvest 類別生成案例完成採收的任務: def turn(int):\n    for i in range(int):\n        turn_left()\n        \ndef new_move(int):\n    for i in range(int):\n        move()\n        \ndef harvest_one_row():\n    while object_here():\n        take()\n    else:\n        move()\n# move to the field\nnew_move(2)\nturn_left()\nnew_move(2)\n\nfor i in range(3):\n    while is_facing_north():\n        for i in range(6):\n            harvest_one_row()\n        for i in range(2):\n            turn(3)\n            move() \n    else:\n        for i in range(6):\n            harvest_one_row()\n        for i in range(2):\n            turn_left()\n            move() \n AI 回答:\xa0 https://mde.tw/cp2025/reeborg?lang=en&mode=python&menu=worlds/menus/select_collection_en.json&name=Alone&url=worlds/tutorial_en/harvest1.json&editor=python/harvest1_class_ex1.py \xa0 \n 進一步要求: \n 請在類別中加上一個採收方向的參數, 內建變數是 horizontal 採收, 也就是由西邊往東邊的水平方向進行採收, 但若該方向變數設為 vertical 則會由南邊往北的所謂垂直方向進行採收 \n AI 回應:\xa0 https://mde.tw/cp2025/reeborg?lang=en&mode=python&menu=worlds/menus/select_collection_en.json&name=Alone&url=worlds/tutorial_en/harvest1.json&editor=python/harvest1_class_ex2.py\xa0 \xa0 \n 延伸到採收 harvest2 農田:\xa0 https://mde.tw/cp2025/reeborg/?lang=en&mode=python&menu=worlds/menus/select_collection_en.json&name=Alone&url=worlds/tutorial_en/harvest2.json&editor=python/harvest1_class_ex1.py \xa0 \n 但卻沒能套用到 harvest3 農田:\xa0 https://mde.tw/cp2025/reeborg/?lang=en&mode=python&menu=worlds/menus/select_collection_en.json&name=Alone&url=worlds/tutorial_en/harvest3.json&editor=python/harvest1_class_ex1.py \xa0 \n 而必須要在每一個座標點留下或放入一個紅蘿蔔:\xa0 https://mde.tw/cp2025/reeborg/?lang=en&mode=python&menu=worlds/menus/select_collection_en.json&name=Alone&url=worlds/tutorial_en/harvest3.json&editor=python/harvest1_class_ex3.py\xa0 \xa0 \n', 'tags': '', 'url': 'ex1.html'}, {'title': 'Otto_ninja', 'text': 'https://www.printables.com/model/231580-otto-ninja-starter-robot/files \xa0 \n \n', 'tags': '', 'url': 'Otto_ninja.html'}, {'title': 'Pyodide', 'text': 'Pyodide  是一個將  Python  解譯器和常用科學套件 (例如:  numpy 、 scipy 、 matplotlib \xa0等) 編譯成  WebAssembly ，可在瀏覽器中執行  Python \xa0程式的專案。 \n Pyodide  是將  CPython  編譯為  WebAssembly ，可在瀏覽器或其他  WebAssembly  環境中執行；而  CPython  是標準的原生  Python  解譯器，運行在作業系統上。換言之， Pyodide  是為在瀏覽器中執行  Python  而設計的  CPython  移植版本。 Pyodide \xa0可與  JavaScript  雙向互動，讓  Python  程式能呼叫  JavaScript  函數並操作網頁元素，也能被  JavaScript  呼叫執行  Python  程式碼。 \n \n \n \n version   hello   1 add to 100   機器人巡邏 自由行   numpy_ode \n  Ace Editor Scripts  \n \n \n \n \n \n \n \n \n  Editor 1  \n \n Run   Output   清除輸出區   Reload \n \n \n \n \n \n 從 1 累加到 100 part2: \n 1 add to 100 \n  Editor 2  \n \n Run   Output   清除輸出區   Reload \n \n \n \n \n \n \n \n', 'tags': '', 'url': 'Pyodide.html'}, {'title': 'Pyodide_ex', 'text': 'Pyodide 機器人巡邏 \xa0- 由於網頁載入場景圍牆與 Pyodide 執行機器人行走模擬的速度差異，機器人巡邏畫面的圍牆無法及時顯示。 \n 經過場景圍牆多次 (目前為 3 次) 載入 (必須配合瀏覽器 Client 端執行速度與網路傳輸速度進行調整)， Pyodide 機器人巡邏2  可以正確載入圍牆圖檔。 \n Pyodide 導入客製化模組: \n const code = `\n# 定義一個模組內容\ndef hello():\n    print("Hello from custom module!")\n`;\npyodide.runPython(code);\n \n Volume_max_pyodide_de_short.py \n Volume_max_pyodide_de.py \n \n', 'tags': '', 'url': 'Pyodide_ex.html'}, {'title': 'Pyodide2', 'text': 'Pyodide2 在頁面中導入  robot.py \xa0(註解版:  pyodide_robot_commented.py ) 後，可以直接在頁面編輯器中，直接利用 walk() 與 turn_left() 兩個方法，引導 機器人前行與左轉 。也可以在編輯器中自行 定義右轉方法 ，賦予機器人更多功能。 \n \n \n \n version   hello   1 add to 100   機器人巡邏   自由行   numpy_ode \n  Ace Editor Scripts  \n \n \n \n \n \n \n \n \n  Editor 1  \n \n Run   Output   清除輸出區   Reload \n \n \n \n \n \n 從 1 累加到 100 part2: \n 1 add to 100 \n  Editor 2  \n \n Run   Output   清除輸出區   Reload \n \n \n \n \n \n \n \n', 'tags': '', 'url': 'Pyodide2.html'}, {'title': 'robot.py', 'text': 'robot.py \n 第一段：模組匯入與常數定義 \n js 是 Brython 提供的 JS-Python 橋接模組，可直接操作 JavaScript DOM。 asyncio 是 Python 的非同步處理模組，用來讓動畫非同步進行。 CELL_SIZE 設定地圖中每個格子的大小（40px × 40px）。 WALL_THICKNESS 是用於繪製牆壁的線條厚度。 IMG_PATH 是儲存所有圖片的伺服器路徑（用於載入牆壁與機器人圖）。 \n import js, asyncio\n\n# 每個格子的像素寬度\nCELL_SIZE = 40\n\n# 牆壁的厚度（像素）\nWALL_THICKNESS = 6\n\n# 圖片資源的網址前綴\nIMG_PATH = "https://mde.tw/cp2025/reeborg/src/images/"\n \n 第二段：World 類別 – 建立世界與地圖圖層 \n World 類負責建立整個地圖畫面，並初始化所需的畫布圖層。 _image_cache 是類別層級變數，用來快取圖片物件。 \n class World:\n    _image_cache = {}  # 用來暫存載入過的圖片，避免重複下載\n\n    def __init__(self, width, height):\n        self.width = width     # 地圖寬（幾格）\n        self.height = height   # 地圖高（幾格）\n        self.layers = self._create_layers()  # 建立四個 canvas 圖層\n        self._init_html()      # 將圖層與控制按鈕加到 HTML 畫面\n \n 第三段：建立圖層 \n 這些圖層都是 canvas 元素，彼此重疊在一起，依序繪製地圖。 \n     def _create_layers(self):\n        return {\n            "grid": js.document.createElement("canvas"),    # 網格底圖\n            "walls": js.document.createElement("canvas"),   # 牆壁\n            "objects": js.document.createElement("canvas"), # 痕跡/物件\n            "robots": js.document.createElement("canvas"),  # 機器人\n        }\n \n 第四段：初始化 HTML 結構 \n 建立一個 container 容器，設定為相對定位。 將四層 canvas 疊放進容器中，每層用不同的 zIndex 疊層排序。 \n     def _init_html(self):\n        container = js.document.createElement("div")\n        container.style.position = "relative"\n        container.style.width = f"{self.width * CELL_SIZE}px"\n        container.style.height = f"{self.height * CELL_SIZE}px"\n\n        for z, canvas in enumerate(self.layers.values()):\n            canvas.width = self.width * CELL_SIZE\n            canvas.height = self.height * CELL_SIZE\n            canvas.style.position = "absolute"\n            canvas.style.top = "0px"\n            canvas.style.left = "0px"\n            canvas.style.zIndex = str(z)\n            container.appendChild(canvas)\n \n 第五段：建立控制按鈕並加入畫面 \n 建立兩個按鈕：「前進」與「左轉」。 設定美觀的樣式（內邊距、字體大小等）。 \n         button_container = js.document.createElement("div")\n        button_container.style.marginTop = "10px"\n        button_container.style.textAlign = "center"\n\n        move_button = js.document.createElement("button")\n        move_button.innerHTML = "Move Forward"\n        move_button.style.margin = "5px"\n        move_button.style.padding = "10px 20px"\n        move_button.style.fontSize = "16px"\n        button_container.appendChild(move_button)\n\n        turn_button = js.document.createElement("button")\n        turn_button.innerHTML = "Turn Left"\n        turn_button.style.margin = "5px"\n        turn_button.style.padding = "10px 20px"\n        turn_button.style.fontSize = "16px"\n        button_container.appendChild(turn_button)\n \n \xa0第六段：掛載進 HTML 與按鈕綁定 \n 將畫面掛載到 HTML 中的 brython_div1 元素內。 同時記錄兩個按鈕到 self.move_button、self.turn_button 屬性，以便之後綁定事件 \n         brython_div = js.document.getElementById("brython_div1")\n        if not brython_div:\n            raise RuntimeError("🚨 \'brython_div1\' element not found in HTML!")\n        brython_div.innerHTML = ""\n        brython_div.appendChild(container)\n        brython_div.appendChild(button_container)\n\n        self.move_button = move_button\n        self.turn_button = turn_button\n \n 第七段：繪製地圖網格線（grid） \n 這段程式會畫出地圖的格線，形成棋盤狀的網格。 每格大小為 CELL_SIZE = 40 像素。 格線只是視覺輔助，沒有碰撞作用。 \n     def _draw_grid(self):\n        ctx = self.layers["grid"].getContext("2d")  # 取得網格圖層的繪圖上下文\n        ctx.strokeStyle = "#cccccc"  # 設定線條顏色為淡灰色\n\n        # 垂直線（每列格線）\n        for i in range(self.width + 1):\n            ctx.beginPath()\n            ctx.moveTo(i * CELL_SIZE, 0)\n            ctx.lineTo(i * CELL_SIZE, self.height * CELL_SIZE)\n            ctx.stroke()\n\n        # 水平線（每欄格線）\n        for j in range(self.height + 1):\n            ctx.beginPath()\n            ctx.moveTo(0, j * CELL_SIZE)\n            ctx.lineTo(self.width * CELL_SIZE, j * CELL_SIZE)\n            ctx.stroke()\n \n 第八段：通用繪圖函式 _draw_image() \n 此函式負責畫圖片在指定格子位置。 需要傳入： \xa0 \xa0 ctx: 要繪製的畫布上下文。 \xa0 \xa0 img_key: 要畫的圖片鍵（例如 "blue_robot_e"）。 \xa0 \xa0 (x, y): 要畫在哪個格子（以地圖邏輯座標為主）。 \xa0 \xa0 (w, h): 圖片的寬與高。 會自動調整畫面位置，將 y 軸上下反轉，使原點在左下角。 \n     def _draw_image(self, ctx, img_key, x, y, w, h, offset_x=0, offset_y=0):\n        img = World._image_cache.get(img_key)\n        if img and img.complete and img.naturalWidth > 0:\n            px = x * CELL_SIZE + offset_x\n            py = (self.height - 1 - y) * CELL_SIZE + offset_y\n            ctx.drawImage(img, px, py, w, h)\n            return True\n        else:\n            print(f"⚠️ Image \'{img_key}\' not ready for drawing.")\n            return False\n \n 第九段：繪製牆壁 _draw_walls() \n 這段會將四周的「邊界牆」畫出來。 利用 _draw_image 畫出 north.png 與 east.png。 offset_x / offset_y 用來對齊圖片位置（不會蓋到格子內）。 \n     async def _draw_walls(self):\n        ctx = self.layers["walls"].getContext("2d")\n        ctx.clearRect(0, 0, self.width * CELL_SIZE, self.height * CELL_SIZE)\n        success = True\n\n        # 繪製上下兩排的北牆（頂部與底部）\n        for x in range(self.width):\n            success &= self._draw_image(ctx, "north", x, self.height - 1, CELL_SIZE, WALL_THICKNESS, offset_y=0)\n            success &= self._draw_image(ctx, "north", x, 0, CELL_SIZE, WALL_THICKNESS, offset_y=CELL_SIZE - WALL_THICKNESS)\n\n        # 繪製左右兩側的東牆（左邊與右邊）\n        for y in range(self.height):\n            success &= self._draw_image(ctx, "east", 0, y, WALL_THICKNESS, CELL_SIZE, offset_x=0)\n            success &= self._draw_image(ctx, "east", self.width - 1, y, WALL_THICKNESS, CELL_SIZE, offset_x=CELL_SIZE - WALL_THICKNESS)\n\n        return success\n \n 第十段：預先載入圖片 _preload_images() \n 此函式會載入所有需要用到的圖片（牆壁與機器人朝向圖）。 利用 Promise 建立圖片載入完成的非同步事件，確保載入成功。 透過 await js.await_promise(js.Promise.all(...)) 等待所有圖片載入完畢。 \n     async def _preload_images(self):\n        image_files = {\n            "blue_robot_e": "blue_robot_e.png",\n            "blue_robot_n": "blue_robot_n.png",\n            "blue_robot_w": "blue_robot_w.png",\n            "blue_robot_s": "blue_robot_s.png",\n            "north": "north.png",\n            "east": "east.png",\n        }\n\n        promises = []\n        for key, filename in image_files.items():\n            if key in World._image_cache and World._image_cache[key].complete:\n                continue\n\n            img = js.document.createElement("img")\n            img.crossOrigin = "Anonymous"\n            img.src = IMG_PATH + filename\n            World._image_cache[key] = img\n\n            def make_promise(img_element):\n                def executor(resolve, reject):\n                    def on_load(event):\n                        img_element.removeEventListener("load", on_load)\n                        img_element.removeEventListener("error", on_error)\n                        resolve(img_element)\n                    def on_error(event):\n                        img_element.removeEventListener("load", on_load)\n                        img_element.removeEventListener("error", on_error)\n                        reject(f"Failed to load image: {img_element.src}")\n                    img_element.addEventListener("load", on_load)\n                    img_element.addEventListener("error", on_error)\n                    if img_element.complete and img_element.naturalWidth > 0:\n                        resolve(img_element)\n                return js.Promise.new(executor)\n\n            promises.append(make_promise(img))\n\n        if not promises:\n            return True\n        try:\n            await js.await_promise(js.Promise.all(promises))\n            return True\n        except Exception as e:\n            print(f"🚨 Error during image preloading: {str(e)}")\n            return False\n \n 第十一段：初始化地圖與資源 setup() \n setup() 是建構完世界後必須呼叫的初始化函式。 包含資源載入、地圖格線與牆壁的繪製。 使用 asyncio.sleep(0) 是一種「讓出主控權給瀏覽器」的技巧，避免卡住畫面。 \n     async def setup(self):\n        # 嘗試三次載入圖片資源，若載入成功則跳出迴圈\n        for _ in range(3):\n            if await self._preload_images():\n                break\n            await asyncio.sleep(0.5)  # 等待 0.5 秒後再試\n        else:\n            print("🚨 Failed to preload images after retries.")\n            return False\n\n        await asyncio.sleep(0)  # 放棄當前事件迴圈執行權，確保 UI 有機會更新\n\n        self._draw_grid()  # 繪製底層的網格\n\n        # 嘗試三次繪製牆壁，等待圖片載入完成\n        for _ in range(3):\n            if await self._draw_walls():\n                break\n            await asyncio.sleep(0.5)\n        else:\n            print("🚨 Failed to draw walls after retries.")\n            return False\n\n        # 最後確認機器人朝向東的圖片是否可用\n        robot_img_key = "blue_robot_e"\n        if not (World._image_cache.get(robot_img_key) and World._image_cache[robot_img_key].complete):\n            print(f"🚨 Robot image \'{robot_img_key}\' still not ready after setup!")\n            return False\n\n        return True  # 所有步驟成功後回傳 True\n \n 第十二段：機器人類別 Robot \n 每個 Robot 物件都有座標與面向，並能畫出自己與移動的軌跡。 傳入 world 是為了能取得地圖的畫布資訊。 \n class Robot:\n    def __init__(self, world, x, y):\n        self.world = world\n        self.x = x - 1  # 將人類習慣的 1-index 轉成 0-index\n        self.y = y - 1\n        self.facing = "E"  # 預設朝東（右邊）\n        self._facing_order = ["E", "N", "W", "S"]  # 左轉時的順序\n\n        self.robot_ctx = world.layers["robots"].getContext("2d")   # 機器人圖層\n        self.trace_ctx = world.layers["objects"].getContext("2d")  # 移動軌跡圖層\n\n        self._draw_robot()  # 初始畫上機器人\n \n _robot_image_key()：依面向回傳圖片鍵 \n 根據面向回傳對應的圖片鍵，例如  E  會回傳  "blue_robot_e" 。 \n     def _robot_image_key(self):\n        return f"blue_robot_{self.facing.lower()}"\n \n _draw_robot()：畫出機器人圖像 \n 先清除原圖，避免留下殘影，再畫上新的機器人圖像。 \n     def _draw_robot(self):\n        self.robot_ctx.clearRect(0, 0, self.world.width * CELL_SIZE, self.world.height * CELL_SIZE)\n        self.world._draw_image(self.robot_ctx, self._robot_image_key(), self.x, self.y, CELL_SIZE, CELL_SIZE)\n \n _draw_trace()：畫出移動路徑 \n 此方法畫出機器人從起點到終點的直線軌跡。 \n     def _draw_trace(self, from_x, from_y, to_x, to_y):\n        ctx = self.trace_ctx\n        ctx.strokeStyle = "#d33"  # 紅色線條\n        ctx.lineWidth = 2\n        ctx.beginPath()\n        fx = from_x * CELL_SIZE + CELL_SIZE / 2\n        fy = (self.world.height - 1 - from_y) * CELL_SIZE + CELL_SIZE / 2\n        tx = to_x * CELL_SIZE + CELL_SIZE / 2\n        ty = (self.world.height - 1 - to_y) * CELL_SIZE + CELL_SIZE / 2\n        ctx.moveTo(fx, fy)\n        ctx.lineTo(tx, ty)\n        ctx.stroke()\n \n 第十三段：機器人行走與轉彎 \n walk(steps)：前進 \n 根據面向方向更新位置，並畫出移動。 超出地圖邊界時停止。 \n     async def walk(self, steps=1):\n        for _ in range(steps):\n            from_x, from_y = self.x, self.y\n            dx, dy = 0, 0\n            if self.facing == "E": dx = 1\n            elif self.facing == "W": dx = -1\n            elif self.facing == "N": dy = 1\n            elif self.facing == "S": dy = -1\n\n            next_x = self.x + dx\n            next_y = self.y + dy\n\n            if 0 <= next_x < self.world.width and 0 <= next_y < self.world.height:\n                self.x, self.y = next_x, next_y\n                self._draw_trace(from_x, from_y, self.x, self.y)\n                self._draw_robot()\n                await asyncio.sleep(0.2)\n            else:\n                print("🚨 Hit a wall, stop moving!")\n                break\n \n turn_left()：左轉 \n 從目前面向向左轉一格，更新圖片。 \n     async def turn_left(self):\n        idx = self._facing_order.index(self.facing)\n        self.facing = self._facing_order[(idx + 1) % 4]  # 循環轉向\n        self._draw_robot()\n        await asyncio.sleep(0.3)\n \n 第十四段：綁定控制 _bind_controls(robot) \n 定義一個私有方法，將控制行為綁定給特定 robot 實例。 \n def _bind_controls(robot: Robot):\n \n 鍵盤控制 \n 設定 j → 前進，i → 左轉。 使用 asyncio.create_task() 以非同步方式執行，避免卡住主執行緒。 \n     def handle_key(event):\n        try:\n            if event.key == \'j\':\n                asyncio.create_task(robot.walk(1))     # 按下 j 移動一步\n            elif event.key == \'i\':\n                asyncio.create_task(robot.turn_left()) # 按下 i 左轉\n        except Exception as e:\n            print(f"🚨 Error in key handler: {e}")\n \n 按鈕點擊控制 \n 這兩個函式綁定到 UI 裡的按鈕（前面 _init_html() 中定義的）。 功能與鍵盤控制一樣，只是透過滑鼠點擊。 \n     def handle_move_button(event):\n        try:\n            asyncio.create_task(robot.walk(1))\n        except Exception as e:\n            print(f"🚨 Error in move button handler: {e}")\n\n    def handle_turn_button(event):\n        try:\n            asyncio.create_task(robot.turn_left())\n        except Exception as e:\n            print(f"🚨 Error in turn button handler: {e}")\n \n 註冊事件到 JavaScript \n 將 handle_key() 註冊為全域 py_handle_key，讓 JavaScript 層級可以呼叫 Python。 \n 將按鈕的點擊事件對應到 Python 定義的控制函式。 \n     js.window.py_handle_key = handle_key\n    js.document.addEventListener(\'keydown\', js.Function("event", "py_handle_key(event);"))\n    js.window.py_handle_move_button = handle_move_button\n    js.window.py_handle_turn_button = handle_turn_button\n    robot.world.move_button.addEventListener(\'click\', js.Function("event", "py_handle_move_button(event);"))\n    robot.world.turn_button.addEventListener(\'click\', js.Function("event", "py_handle_turn_button(event);")) \n 第十五段：初始化並啟動 init() \n 提供一個使用者簡單快速初始化整個世界與機器人的介面。 \n def init(world_width=10, world_height=10, robot_x=1, robot_y=1):\n \n 包裝為非同步任務 \n 這個包裝函式 async def _inner() 是用來實作內部非同步邏輯。 \n     async def _inner():\n        world = World(world_width, world_height)  # 建立世界\n        if not await world.setup():               # 等待世界初始化完成\n            raise RuntimeError("World setup failed!")  # 若失敗則丟出錯誤\n\n        robot = Robot(world, robot_x, robot_y)    # 建立機器人\n        _bind_controls(robot)                     # 綁定控制事件\n        return world, robot                       # 傳回 world 和 robot 物件\n \n 建立並啟動非同步任務 \n     return asyncio.create_task(_inner())\n \n 回傳一個非同步任務（asyncio.Task），讓使用者可以這樣呼叫： \n world, robot = await init(10, 10, 1, 1)\n \n 等待 init() 的結果後，就可以直接控制 robot.walk() 或 robot.turn_left()。 \n', 'tags': '', 'url': 'robot.py.html'}, {'title': 'Example2', 'text': '自行定義機器人右轉的非同步執行函式: \n 執行 turn_right 程式 範例。 \n import robot\nimport asyncio\n\n# 定義右轉的非同步函式\nasync def turn_right(bot):\n    for _ in range(3):\n        await bot.turn_left()\n\nasync def main():\n    world, bot = await robot.init(10, 10, 1, 1)\n    print("機器人開始行動")\n    await bot.turn_left()\n    await bot.walk(9)\n    await turn_right(bot) \n    print("機器人完成行動")\n\n# main() 讓出執行控制權，由頁面中的 even loop 決定何時執行 main()\nawait main()\n \n', 'tags': '', 'url': 'Example2.html'}, {'title': 'Pyodide3', 'text': 'Pyodide3 則在  Pyodide  與  Pyodide2  頁面架構下，進一步導入  robot_w_world.py ，在既有的水平圍牆  north.png  與垂直圍牆  east.png  檔案之外，加入  carrot.png 、 grass.png  與  pale_grass.png  等圖檔。並且擴充可從 URL 讀進 json 格式的 world 變數功能，以便製作出更多元的場景任務，要求機器人執行。 \n 其中 src URL 變數，可以將網路上的機器人控制程式導入 Pyodide3 頁面外，world URL 變數則可以導入源自  Reeborg  機器人程式所設定的 json 格式場景。 \n 由於 Reeborg 系統中的 png 圖檔均非透明背景， robot_w_world.py \xa0必須利用 HTML 中的 CANVAS，將關鍵的白色背景，以透明的方式顯示。 \n src URL 變數讀進  turn_right 程式 ，而 world URL 變數則讀進  harvest2.json ，執行 結果 。 \n 讀進  harvest3.json , 執行 結果 。 \n \n \n \n version   hello   1 add to 100   機器人巡邏   自由行   numpy_ode \n  Ace Editor Scripts  \n \n \n \n \n \n \n \n \n  Editor 1  \n \n Run   Output   清除輸出區   Reload \n \n \n \n \n \n 從 1 累加到 100 part2: \n 1 add to 100 \n  Editor 2  \n \n Run   Output   清除輸出區   Reload \n \n \n \n \n \n \n \n', 'tags': '', 'url': 'Pyodide3.html'}, {'title': 'png_files', 'text': '利用  robot_w_world.py  將 png 圖檔實踐「關鍵色透明」: 作法是在程式碼中額外添加像素處理的邏輯。Canvas 的 drawImage 方法本身不會自動識別並跳過特定顏色的像素，所以我們必須手動介入。 處理方法: 要讓  robot_w_world.py  實現這個功能，必須修改 _draw_image 方法，或者在圖片載入後進行預處理。最直接的方法是在繪製數字圖片時，讀取其像素數據，並將特定顏色（例如白色）的像素的 Alpha 值設置為 0。 這會涉及以下步驟： \xa0 \xa0 取得圖片像素資料： 將圖片繪製到一個臨時的、看不見的 Canvas 上。 \xa0 \xa0 讀進所有像素： 讀取這個臨時 Canvas 的像素資料。 \xa0 \xa0 修改像素的 Alpha 值： 檢查每個像素的 RGB 值，如果它符合預設的「關鍵色」（例如，純白色 (255, 255, 255)），就將其 Alpha (透明度) 值設為 0。 \xa0 \xa0 將修改後的像素資料放回： 將修改後的像素資料重新放回臨時 Canvas。 \xa0 \xa0 繪製臨時 Canvas： 最後，將這個處理過的臨時 Canvas 繪製到我們實際要顯示的圖層上。 缺點與考量: \xa0 \xa0 性能影響： 像素級的處理是相對耗費資源的，特別是當有很多數字需要顯示時。這可能會導致動畫或初始加載時出現輕微的延遲。 \xa0 \xa0 複雜性增加： 程式碼會變得更複雜，需要處理 Canvas API 的 getImageData 和 putImageData 方法。 \xa0 \xa0 關鍵色選擇： 您需要確定一個所有數字圖片背景都一致的「關鍵色」。如果有些數字圖片背景是白色，有些是淺灰色，這個方法就會失效。 \n', 'tags': '', 'url': 'png_files.html'}, {'title': 'Harvest', 'text': 'Pyodide3  在頁面中導入  robot_w_world.py \xa0後，可以透過\xa0 pyodide3_harvest_ex1.py \xa0繼承 robot 物件，加入農作物採收功能。 \n 但因為\xa0 robot_w_world.py \xa0版本中的 trace 繪製圖層並未獨立，除了採收農作物之後的座標背景會從 pale_grass.png 置換為 grass.png 外，農作物採收後的座標畫面刷新會一併將之前的機器人行走路徑刪除，因此後續版本必須將所有不同屬性的圖像，以各自的獨立圖層進行繪製，才不會互相影響下，產生錯誤的機器人農作物採收模擬。 \n 在 Pyodide3 執行\xa0 pyodide3_harvest_ex1.py ，執行 結果 。 \n', 'tags': '', 'url': 'Harvest.html'}]};