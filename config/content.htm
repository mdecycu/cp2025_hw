<h1>About</h1>
<p>Repo: <a href="https://github.com/mdecycu/cp2025_hw">https://github.com/mdecycu/cp2025_hw</a> (請修改為您的作業倉儲)</p>
<p>Site: <a href="https://mdecycu.github.io/cp2025_hw">https://mdecycu.github.io/cp2025_hw</a> (請修改為您的作業網站)</p>
<p>可攜程式套件:</p>
<p style="padding-left: 30px;"><a href="http://229.cycu.org/portable_2026.7z">portable_2026.7z</a> (387MB)</p>
<p style="padding-left: 60px;">解開壓縮後，雙點擊 start_miniconda3.bat 啟動可攜系統，雙點擊 stop.bat 關閉可攜系統。</p>
<p style="padding-left: 60px;">可攜系統啟動後，在命令列執行 conda activate y:\envs\cmsimde 可進入能執行 CMSiMDE 的環境。</p>
<p style="padding-left: 60px;">若希望可攜系統啟動直接進入 cmsimde 環境，可將 start_miniconda3.bat 檔案中第 98 行: call "%CONDA_ROOT%\Scripts\activate.bat" %ENV_NAME% 更換為 call "%CONDA_ROOT%\Scripts\activate.bat" %Disk%:\envs\cmsimde</p>
<h1>Homework</h1>
<p>HW1:</p>
<p style="padding-left: 30px;">請將程式碼存放在個人作業倉儲中的 python 目錄後，利用程式連結完成下列任務:</p>
<p style="padding-left: 60px;"><a href="https://mde.tw/cp2025/reeborg/?lang=en&amp;mode=python&amp;menu=worlds%2Fmenus%2Fselect_collection_en.json&amp;name=Alone&amp;url=worlds%2Ftutorial_en%2Faround1.json">around1</a>, <a href="https://mde.tw/cp2025/reeborg/?lang=en&amp;mode=python&amp;menu=worlds%2Fmenus%2Fselect_collection_en.json&amp;name=Alone&amp;url=worlds%2Ftutorial_en%2Faround2.json">around2</a>, <a href="https://mde.tw/cp2025/reeborg/?lang=en&amp;mode=python&amp;menu=worlds%2Fmenus%2Fselect_collection_en.json&amp;name=Alone&amp;url=worlds%2Ftutorial_en%2Faround3.json">around3</a>, <a href="https://mde.tw/cp2025/reeborg/?lang=en&amp;mode=python&amp;menu=worlds%2Fmenus%2Fselect_collection_en.json&amp;name=Alone&amp;url=worlds%2Ftutorial_en%2Faround4.json">around4</a></p>
<p>HW2:</p>
<p style="padding-left: 30px;">請修改 <a href="https://mde.tw/cp2025/content/Brython.html?src=https://gist.githubusercontent.com/mdecycu/ec4bb35dd0769e7a83d2a9fa57878a67/raw/b33c5fc2a0774f8c5d2b0e8c7c7908e58d73bb94/robot_1.py">Brython_robot</a> 程式，讓機器人可以採水平巡邏方式，走過每一個區域。</p>
<p style="padding-left: 30px;">請修改 <a href="https://mde.tw/cp2025/content/Brython.html?src=https://gist.githubusercontent.com/mdecycu/ec4bb35dd0769e7a83d2a9fa57878a67/raw/b33c5fc2a0774f8c5d2b0e8c7c7908e58d73bb94/robot_1.py">Brython_robot</a> 程式，讓機器人可以採上下垂直巡邏方式，走過每一個區域。</p>
<p>HW3:</p>
<p style="padding-left: 30px;">請修改 <a href="https://mde.tw/cp2025/content/Brython.html?src=https://gist.githubusercontent.com/mdecycu/58fed8bd2f5be98a6456a8dcae512011/raw/4019adba4ee4be19c35982d835bad8e7d83a7b2f/brython_robot4_ex1.py">brython_robot4_ex1.py</a> 程式，讓機器人可以與<a href="https://mde.tw/cp2025/reeborg/?lang=en&amp;mode=python&amp;menu=worlds%2Fmenus%2Fselect_collection_en.json&amp;name=Alone&amp;url=worlds%2Ftutorial_en%2Fharvest1.json&amp;editor=python%2Fharvest1_east_west.py">機器人收割程式</a>的水平採收方式相同。</p>
<p style="padding-left: 30px;">請修改 <a href="https://mde.tw/cp2025/content/Brython.html?src=https://gist.githubusercontent.com/mdecycu/58fed8bd2f5be98a6456a8dcae512011/raw/4019adba4ee4be19c35982d835bad8e7d83a7b2f/brython_robot4_ex1.py">brython_robot4_ex1.py</a> 程式，讓機器人可以與<a href="https://mde.tw/cp2025/reeborg/?lang=en&amp;mode=python&amp;menu=worlds%2Fmenus%2Fselect_collection_en.json&amp;name=Alone&amp;url=worlds%2Ftutorial_en%2Fharvest1.json&amp;editor=python%2Fharvest1.py">機器人收割程式</a>的上下垂直採收方式相同。</p>
<p>HW4:</p>
<p style="padding-left: 30px;">請修改 <a href="https://mde.tw/cp2025/content/Brython.html?src=https://gist.githubusercontent.com/mdecycu/58fed8bd2f5be98a6456a8dcae512011/raw/4019adba4ee4be19c35982d835bad8e7d83a7b2f/brython_robot4_ex1.py">brython_robot4_ex1.py</a> 程式，讓機器人可以與<a href="https://mde.tw/cp2025/reeborg/?lang=en&amp;mode=python&amp;menu=worlds%2Fmenus%2Fselect_collection_en.json&amp;name=Alone&amp;url=worlds%2Ftutorial_en%2Fharvest3.json&amp;editor=python%2Fharvest1_class_ex3.py">機器人收割程式</a>的採收與播種方式相同。</p>
<p style="padding-left: 30px;">請修改 Pyodide <a href="https://mde.tw/cp2025/content/Pyodide.html?src=https://gist.githubusercontent.com/mdecycu/ec4bb35dd0769e7a83d2a9fa57878a67/raw/d1659628afe5d36a026ef305dc639f6be4c9f608/pyodide_robot_ex3.py">機器人自由行</a>程式，讓機器人可以採水平巡邏方式，走過每一個區域。</p>
<p style="padding-left: 30px;">請修改 Pyodide <a href="https://mde.tw/cp2025/content/Pyodide2.html?src=https%3A%2F%2Fgist.githubusercontent.com%2Fmdecycu%2Fec4bb35dd0769e7a83d2a9fa57878a67%2Fraw%2Fff833d14181c7e270d37432aa8589f5ecf00e383%2Fpyodide_walk_around2.py">機器人自由行2</a>程式，讓機器人可以採上下垂直巡邏方式，走過每一個區域。</p>
<p></p>
<p></p>
<h2>HW0</h2>
<p>自行建立 Github 帳號 - <a href="https://github.com/signup">https://github.com/signup</a> </p>
<p>取得個人的作業倉儲 - 透過 <a href="https://classroom.github.com">https://classroom.github.com</a> </p>
<p>設定 Github Pages - 利用作業倉儲建立作業網站</p>
<p>可以直接在瀏覽器上透過 Reeborg、Brython 或 Pyodide 頁面，學習 Python 語法</p>
<p>利用 Codespaces 維護作業內容 - <a href="https://github.com/codespaces">https://github.com/codespaces</a> (免費帳號每月可以使用 120 core小時 + 15GB 儲存，<a href="https://github.com/education/students">學生認證</a>後可使用 180 core小時 + 20GB 儲存)</p>
<p style="padding-left: 30px;"><a href="https://docs.github.com/en/billing/managing-billing-for-your-products/about-billing-for-github-codespaces">https://docs.github.com/en/billing/managing-billing-for-your-products/about-billing-for-github-codespaces</a> </p>
<p>利用可攜程式系統維護作業內容</p>
<p style="padding-left: 30px;"><a href="http://229.cycu.org/portable_2026.7z">portable_2026.7z</a> (387MB) - 在隨身碟或個人電腦上解開壓縮後使用</p>
<p style="padding-left: 60px;">解開壓縮後，雙點擊 start_miniconda3.bat 啟動可攜系統，雙點擊 stop.bat 關閉可攜系統。</p>
<p style="padding-left: 60px;">可攜系統啟動後，在命令列執行 conda activate y:\envs\cmsimde 可進入能執行 CMSiMDE 的環境。</p>
<p style="padding-left: 60px;">若希望可攜系統啟動直接進入 cmsimde 環境，可將 start_miniconda3.bat 檔案中第 98 行: call "%CONDA_ROOT%\Scripts\activate.bat" %ENV_NAME% 更換為 call "%CONDA_ROOT%\Scripts\activate.bat" %Disk%:\envs\cmsimde</p>
<p><a href="https://github.com/mdecycu/python_2025/blob/main/%E7%AC%AC01%E8%AA%B2%EF%BC%9A%E5%88%9D%E8%AD%98Python.md">Python 程式教材</a></p>
<p style="padding-left: 30px;">使用 Reeborg 學習 Python: <a href="https://mde.tw/cp2025/content/Reeborg.html">https://mde.tw/cp2025/content/Reeborg.html</a> </p>
<p style="padding-left: 30px;">使用 Brython 學習 Python: <a href="https://mde.tw/cp2025/content/Brython.html">https://mde.tw/cp2025/content/Brython.html</a> </p>
<p style="padding-left: 30px;">使用 Pyodide 學習 Python: <a href="https://mde.tw/cp2025/content/Pyodide.html">https://mde.tw/cp2025/content/Pyodide.html</a> </p>
<p>機械設計工程師學習 Python 做甚麼? - 請自行<a href="https://chatgpt.com/?openaicom_referred=true">利用 ChatGPT 提問</a></p>
<p style="padding-left: 30px;"><br/><br/><br/>    </p>
<p></p>
<p></p>
<p style="padding-left: 30px;"></p>
<h2>HW1</h2>
<p>請將程式碼存放在個人作業倉儲中的 python 目錄後，利用程式連結完成下列任務:</p>
<p style="padding-left: 30px;"><a href="https://mde.tw/cp2025/reeborg/?lang=en&amp;mode=python&amp;menu=worlds%2Fmenus%2Fselect_collection_en.json&amp;name=Alone&amp;url=worlds%2Ftutorial_en%2Faround1.json">around1</a>, <a href="https://mde.tw/cp2025/reeborg/?lang=en&amp;mode=python&amp;menu=worlds%2Fmenus%2Fselect_collection_en.json&amp;name=Alone&amp;url=worlds%2Ftutorial_en%2Faround2.json">around2</a>, <a href="https://mde.tw/cp2025/reeborg/?lang=en&amp;mode=python&amp;menu=worlds%2Fmenus%2Fselect_collection_en.json&amp;name=Alone&amp;url=worlds%2Ftutorial_en%2Faround3.json">around3</a>, <a href="https://mde.tw/cp2025/reeborg/?lang=en&amp;mode=python&amp;menu=worlds%2Fmenus%2Fselect_collection_en.json&amp;name=Alone&amp;url=worlds%2Ftutorial_en%2Faround4.json">around4</a></p>
<p></p>
<h2>HW2</h2>
<p>請修改 <a href="https://mde.tw/cp2025/content/Brython.html?src=https://gist.githubusercontent.com/mdecycu/ec4bb35dd0769e7a83d2a9fa57878a67/raw/b33c5fc2a0774f8c5d2b0e8c7c7908e58d73bb94/robot_1.py">Brython_robot</a> 程式，讓機器人可以採水平巡邏方式，走過每一個區域。</p>
<p>請修改 <a href="https://mde.tw/cp2025/content/Brython.html?src=https://gist.githubusercontent.com/mdecycu/ec4bb35dd0769e7a83d2a9fa57878a67/raw/b33c5fc2a0774f8c5d2b0e8c7c7908e58d73bb94/robot_1.py">Brython_robot</a> 程式，讓機器人可以採上下垂直巡邏方式，走過每一個區域。</p>
<p></p>
<p></p>
<h2>HW3</h2>
<p>請修改 <a href="https://mde.tw/cp2025/content/Brython.html?src=https://gist.githubusercontent.com/mdecycu/58fed8bd2f5be98a6456a8dcae512011/raw/4019adba4ee4be19c35982d835bad8e7d83a7b2f/brython_robot4_ex1.py">brython_robot4_ex1.py</a> 程式，讓機器人可以與<a href="https://mde.tw/cp2025/reeborg/?lang=en&amp;mode=python&amp;menu=worlds%2Fmenus%2Fselect_collection_en.json&amp;name=Alone&amp;url=worlds%2Ftutorial_en%2Fharvest1.json&amp;editor=python%2Fharvest1_east_west.py">機器人收割程式</a>的水平採收方式相同。</p>
<p>請修改 <a href="https://mde.tw/cp2025/content/Brython.html?src=https://gist.githubusercontent.com/mdecycu/58fed8bd2f5be98a6456a8dcae512011/raw/4019adba4ee4be19c35982d835bad8e7d83a7b2f/brython_robot4_ex1.py">brython_robot4_ex1.py</a> 程式，讓機器人可以與<a href="https://mde.tw/cp2025/reeborg/?lang=en&amp;mode=python&amp;menu=worlds%2Fmenus%2Fselect_collection_en.json&amp;name=Alone&amp;url=worlds%2Ftutorial_en%2Fharvest1.json&amp;editor=python%2Fharvest1.py">機器人收割程式</a>的上下垂直採收方式相同。</p>
<p></p>
<h2>HW4</h2>
<p>請修改 <a href="https://mde.tw/cp2025/content/Brython.html?src=https://gist.githubusercontent.com/mdecycu/58fed8bd2f5be98a6456a8dcae512011/raw/4019adba4ee4be19c35982d835bad8e7d83a7b2f/brython_robot4_ex1.py">brython_robot4_ex1.py</a> 程式，讓機器人可以與<a href="https://mde.tw/cp2025/reeborg/?lang=en&amp;mode=python&amp;menu=worlds%2Fmenus%2Fselect_collection_en.json&amp;name=Alone&amp;url=worlds%2Ftutorial_en%2Fharvest3.json&amp;editor=python%2Fharvest1_class_ex3.py">機器人收割程式</a>的採收與播種方式相同。</p>
<p>請修改 Pyodide <a href="https://mde.tw/cp2025/content/Pyodide.html?src=https://gist.githubusercontent.com/mdecycu/ec4bb35dd0769e7a83d2a9fa57878a67/raw/d1659628afe5d36a026ef305dc639f6be4c9f608/pyodide_robot_ex3.py">機器人自由行</a>程式，讓機器人可以採水平巡邏方式，走過每一個區域。</p>
<p>請修改 Pyodide <a href="https://mde.tw/cp2025/content/Pyodide2.html?src=https%3A%2F%2Fgist.githubusercontent.com%2Fmdecycu%2Fec4bb35dd0769e7a83d2a9fa57878a67%2Fraw%2Fff833d14181c7e270d37432aa8589f5ecf00e383%2Fpyodide_walk_around2.py">機器人自由行2</a>程式，讓機器人可以採上下垂直巡邏方式，走過每一個區域。</p>
<h1>Brython</h1>
<p><button id="add1to100">1 add to 100</button><button id="robot1">機器人巡邏</button><button id="free_walk">自由行</button></p>
<!-- 導入 brython 程式庫 -->
<p>
<script src="/static/brython.js"></script>
<script src="/static/brython_stdlib.js"></script>
</p>
<!-- 啟動 Brython -->
<p>
<script>
window.onload=function(){
brython({debug:1, pythonpath:['/static/','./../downloads/py/']});
}
</script>
</p>
<p><!-- 導入 FileSaver 與 filereader --></p>
<p>
<script src="/static/ace/FileSaver.min.js" type="text/javascript"></script>
<script src="/static/ace/filereader.js" type="text/javascript"></script>
</p>
<p><!-- 導入 ace --></p>
<p>
<script src="/static/ace/ace.js" type="text/javascript"></script>
<script src="/static/ace/ext-language_tools.js" type="text/javascript"></script>
<script src="/static/ace/mode-python3.js" type="text/javascript"></script>
<script src="/static/ace/snippets/python.js" type="text/javascript"></script>
</p>
<p><!-- 導入 gearUtils-0.9.js Cango 齒輪繪圖程式庫 -->
<script src="/static/Cango-24v03-min.js"></script>
<script src="/static/gearUtils-09.js"></script>
<script src="/static/SVGpathUtils-6v03-min.js"></script>
<script src="/static/sylvester.js"></script>
<script src="/static/PrairieDraw.js"></script>
</p>
<p><!-- 請注意, 這裡使用 Javascript 將 localStorage["kw_py_src1"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱--></p>
<p>
<script type="text/javascript">
function doSave(storage_id, filename){
    var blob = new Blob([localStorage[storage_id]], {type: "text/plain;charset=utf-8"});
    filename = document.getElementById(filename).value
    saveAs(blob, filename+".py");
}
</script>
</p>
<p><!-- 累加程式開始 -->
<script type="text/python3">
from browser import document as doc
import ace
# 清除畫布
def clear_bd1(ev):
    bd = doc["brython_div1"]
    bd.clear()
Ace1 = ace.Editor(editor_id="kw_editor1", console_id="kw_console1", container_id="kw__container1", storage_id="kw_py_src1" )
# 從 gist 取出程式碼後, 放入 editor 作為 default 程式
def run1():
    # 利用 get 取下 src 變數值
    try:
        url = doc.query["src"]
    except:
        url = "https://gist.githubusercontent.com/mdecourse/0229a8a017091476a79700b8a190f185/raw/c3a6deaf717f8f2739a4b1392a5ab10936e9693a/from_1_add_to_10_1.py"
    prog = open(url).read()

    # 將程式載入編輯區
    Ace1.editor.setValue(prog)
    Ace1.editor.scrollToRow(0)
    Ace1.editor.gotoLine(0)
    # 直接執行程式
    #ns = {'__name__':'__main__'}
    #exec(prog, ns)
    # 按下 run 按鈕
    Ace1.run()
# 執行程式, 顯示輸出結果與清除輸出結果及對應按鈕綁定
doc['kw_run1'].bind('click', Ace1.run)
doc['kw_show_console1'].bind('click', Ace1.show_console)
doc['kw_clear_console1'].bind('click', Ace1.clear_console)
doc['clear_bd1'].bind('click', clear_bd1)
# 呼叫函式執行
run1()
</script>
<!-- 累加程式結束 --> <!-- 機器人巡邏程式開始 -->
<script type="text/python3">
from browser import document as doc
import ace

# 清除畫布
def clear_bd1(ev):
    bd = doc["brython_div1"]
    bd.clear()

# 利用 ace 中的 Editor 建立 Ace2 物件, 其中的輸入變數分別對應到頁面中的編輯區物件
Ace2 = ace.Editor(editor_id="kw_editor1", console_id="kw_console1", container_id="kw__container1", storage_id="kw_py_src1" )

robot1_url = "https://gist.githubusercontent.com/mdecycu/ec4bb35dd0769e7a83d2a9fa57878a67/raw/b33c5fc2a0774f8c5d2b0e8c7c7908e58d73bb94/robot_1.py"

# 從 gist 取得程式碼
robot1_src = open(robot1_url).read()
def robot1(ev):
    Ace2.editor.setValue(robot1_src)
    Ace2.editor.scrollToRow(0)
    Ace2.editor.gotoLine(0)
    Ace2.run()

# id 為 "robot1" 的按鈕點按時, 執行 robot1 方法
doc["robot1"].bind('click', robot1)
</script>
<!-- 機器人巡邏程式結束 --></p>
<!-- 機器人自由行程式開始 -->
<p>
<script type="text/python3">
from browser import document as doc
import ace

# 清除畫布
def clear_bd1(ev):
    bd = doc["brython_div1"]
    bd.clear()

# 利用 ace 中的 Editor 建立 Ace2 物件, 其中的輸入變數分別對應到頁面中的編輯區物件
Ace2 = ace.Editor(editor_id="kw_editor1", console_id="kw_console1", container_id="kw__container1", storage_id="kw_py_src1" )

free_walk_url = "https://gist.githubusercontent.com/mdecycu/ec4bb35dd0769e7a83d2a9fa57878a67/raw/9d55811467e411eb89f74171d8a586ae9f1a96aa/brython_robot_free_walk.py"

# 從 gist 取得程式碼
free_walk_src = open(free_walk_url).read()
def free_walk(ev):
    Ace2.editor.setValue(free_walk_src)
    Ace2.editor.scrollToRow(0)
    Ace2.editor.gotoLine(0)
    Ace2.run()

# id 為 "free_walk" 的按鈕點按時, 執行 robot1 方法
doc["free_walk"].bind('click', free_walk)
</script>
</p>
<!-- 機器人自由行程式結束 -->
<p><!-- add 1 to 100 開始 -->
<script type="text/python3">
from browser import document as doc
import ace

# 清除畫布
def clear_bd1(ev):
    bd = doc["brython_div1"]
    bd.clear()

# 利用 ace 中的 Editor 建立 Ace2 物件, 其中的輸入變數分別對應到頁面中的編輯區物件
Ace2 = ace.Editor(editor_id="kw_editor1", console_id="kw_console1", container_id="kw__container1", storage_id="kw_py_src1" )

add1to100_url = "https://gist.githubusercontent.com/mdecourse/0229a8a017091476a79700b8a190f185/raw/c48e37714f055c3a0027cbfef59e442a6ef659b9/from_1_add_to_100_1.py"

# 從 gist 取得程式碼
add_src = open(add1to100_url).read()
def add(ev):
    Ace2.editor.setValue(add_src)
    Ace2.editor.scrollToRow(0)
    Ace2.editor.gotoLine(0)
    Ace2.run()

# id 為 "add1to100" 的按鈕點按時, 執行 add 方法
doc["add1to100"].bind('click', add)
</script>
</p>
<p><!-- add 1 to 100 結束--></p>
<!-- editor1 開始 -->
<p><!-- 用來顯示程式碼的 editor 區域 --></p>
<div id="kw_editor1" style="width: 600px; height: 300px;"></div>
<p><!-- 以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合 --></p>
<p><!-- 存擋表單開始 --></p>
<form><label>Filename: <input id="kw_filename" placeholder="input file name" type="text"/>.py</label> <input onclick="doSave('kw_py_src1', 'kw_filename1');" type="submit" value="Save"/></form>
<p><!-- 存擋表單結束 --></p>
<p></p>
<p><!-- 執行與清除按鈕開始 --></p>
<p><button id="kw_run1">Run</button> <button id="kw_show_console1">Output</button> <button id="kw_clear_console1">清除輸出區</button><button id="clear_bd1">清除繪圖區</button><button onclick="window.location.reload()">Reload</button></p>
<p><!-- 執行與清除按鈕結束 --></p>
<p></p>
<p><!-- 程式執行 ouput 區 --></p>
<div style="width: 100%; height: 100%;"><textarea autocomplete="off" id="kw_console1"></textarea></div>
<p><!-- Brython 程式執行的結果, 都以 brython_div1 作為切入位置 --></p>
<div id="brython_div1"></div>
<!-- editor1 結束 --><hr/><!-- ########################################## -->
<p>從 1 累加到 100 part2:</p>
<p><button id="add1to100part2">1 add to 100</button><button id="cango_three_gears">cango_three_gears</button><button id="bsnake">BSnake</button><button id="aitetris">AI Tetris</button></p>
<p><!-- 請注意, 這裡使用 Javascript 將 localStorage["kw_py_src2"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱--></p>
<p>
<script type="text/python3">
from browser import document as doc
import ace
# 清除畫布
def clear_bd2(ev):
    bd = doc["brython_div2"]
    bd.clear()
Ace3 = ace.Editor(editor_id="kw_editor2", console_id="kw_console2", container_id="kw__container2", storage_id="kw_py_src2" )
# 從 gist 取出程式碼後, 放入 editor 作為 default 程式
def run2():
    # 利用 get 取下 src 變數值
    try:
        url = doc.query["src2"]
    except:
        url = "https://gist.githubusercontent.com/mdecourse/0229a8a017091476a79700b8a190f185/raw/c3a6deaf717f8f2739a4b1392a5ab10936e9693a/from_1_add_to_10_1.py"
    prog = open(url).read()

    # 將程式載入編輯區
    Ace3.editor.setValue(prog)
    Ace3.editor.scrollToRow(0)
    Ace3.editor.gotoLine(0)
    # 直接執行程式
    #ns = {'__name__':'__main__'}
    #exec(prog, ns)
    # 按下 run 按鈕
    Ace3.run()

# 執行程式, 顯示輸出結果與清除輸出結果及對應按鈕綁定
doc['kw_run2'].bind('click', Ace3.run)
doc['kw_show_console2'].bind('click', Ace3.show_console)
doc['kw_clear_console2'].bind('click', Ace3.clear_console)
doc['clear_bd2'].bind('click', clear_bd2)
# 呼叫函式執行
run2()
</script>
</p>
<p><!-- add 1 to 100 part2 開始 -->
<script type="text/python3">
from browser import document as doc
import ace

# 清除畫布
def clear_bd2(ev):
    bd = doc["brython_div2"]
    bd.clear()

# 利用 ace 中的 Editor 建立 Ace2 物件, 其中的輸入變數分別對應到頁面中的編輯區物件
Ace4 = ace.Editor(editor_id="kw_editor2", console_id="kw_console2", container_id="kw__container2", storage_id="kw_py_src2" )

# 透過 Ace4 以類別建立一個通用的 button2, 可以在多個案例中將 gist 程導入編輯區

class button2:
    def __init__(self, url):
        self.url = url

    # 記得加入 event 輸入變數
    def do(self,ev):
        Ace4.editor.setValue(open(self.url).read())
        Ace4.editor.scrollToRow(0)
        Ace4.editor.gotoLine(0)
        Ace4.run()

add1to100_url = "https://gist.githubusercontent.com/mdecourse/0229a8a017091476a79700b8a190f185/raw/c48e37714f055c3a0027cbfef59e442a6ef659b9/from_1_add_to_100_1.py"

# 從 gist 取得程式碼
add_src = open(add1to100_url).read()
def add2(ev):
    Ace4.editor.setValue(add_src)
    Ace4.editor.scrollToRow(0)
    Ace4.editor.gotoLine(0)
    Ace4.run()

# id 為 "add1to100part2" 的按鈕點按時, 執行 add 方法
doc["add1to100part2"].bind('click', add2)
# 以下為運用 button2 class 的通用 gist 程式導入區
################################## cango_three_gears start
cango_three_gears_url = "https://gist.githubusercontent.com/mdecycu/d9082d678096bd58378d6afe2c7fa05d/raw/f7a85d737d6723d5e34c526d5daee990ed92c32b/cango_three_gears_brython_div2.py"
cango_three_gears = button2(cango_three_gears_url)
doc["cango_three_gears"].bind("click", cango_three_gears.do)
################################## cango_three_gears end
################################## bsnake start
bsnake_url = "https://gist.githubusercontent.com/mdecycu/d9082d678096bd58378d6afe2c7fa05d/raw/f7a85d737d6723d5e34c526d5daee990ed92c32b/kmol_snakey.py"
bsnake = button2(bsnake_url)
doc["bsnake"].bind("click", bsnake.do)
################################## bsnake end
################################## aitetris start
aitetris_url = "https://gist.githubusercontent.com/mdecycu/d9082d678096bd58378d6afe2c7fa05d/raw/f7a85d737d6723d5e34c526d5daee990ed92c32b/pygame_to_brython_tetris_ai.py"
aitetris = button2(aitetris_url)
doc["aitetris"].bind("click", aitetris.do)
################################## aitetris end
</script>
</p>
<p><!-- add 1 to 100 part2 結束--></p>
<!-- editor2 開始 -->
<p><!-- 用來顯示程式碼的 editor 區域 --></p>
<div id="kw_editor2" style="width: 600px; height: 300px;"></div>
<p><!-- 以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合 --></p>
<p><!-- 存擋表單開始 --></p>
<form><label>Filename: <input id="kw_filename2" placeholder="input file name" type="text"/>.py</label> <input onclick="doSave('kw_py_src2', 'kw_filename2');" type="submit" value="Save"/></form>
<p><!-- 存擋表單結束 --></p>
<p></p>
<p><!-- 執行與清除按鈕開始 --></p>
<p><button id="kw_run2">Run</button> <button id="kw_show_console2">Output</button> <button id="kw_clear_console2">清除輸出區</button><button id="clear_bd2">清除繪圖區</button><button onclick="window.location.reload()">Reload</button></p>
<p><!-- 執行與清除按鈕結束 --></p>
<p></p>
<p><!-- 程式執行 ouput 區 --></p>
<div style="width: 100%; height: 100%;"><textarea autocomplete="off" id="kw_console2"></textarea></div>
<p><!-- Brython 程式執行的結果, 都以 brython_div1 作為切入位置 --></p>
<div id="brython_div2"></div>
<!-- editor2 結束 --><hr/>
<p></p>
<h2>Brython_ex</h2>
<p><a href="https://mde.tw/cp2025/content/Brython.html?src=https://gist.githubusercontent.com/mdecycu/ec4bb35dd0769e7a83d2a9fa57878a67/raw/9d55811467e411eb89f74171d8a586ae9f1a96aa/brython_robot_free_walk.py">機器人自由行</a></p>
<p>Can we bring pythonpad into this page? <a href="https://pythonpad.github.io/docs/manual.html">https://pythonpad.github.io/docs/manual.html</a> </p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">from browser import document, html, timer
 
canvas = html.CANVAS(width=400, height=400)
brython_div = document["brython_div1"]
brython_div &lt;= canvas
ctx = canvas.getContext("2d")
 
def draw_grid():
    ctx.clearRect(0, 0, 400, 400)
    ctx.strokeStyle = "#ccc"
    ctx.lineWidth = 1
    for i in range(0, 401, 40):
        ctx.beginPath()
        ctx.moveTo(i, 0)
        ctx.lineTo(i, 400)
        ctx.stroke()
        ctx.beginPath()
        ctx.moveTo(0, i)
        ctx.lineTo(400, i)
        ctx.stroke()
    
    # 畫出邊界
    ctx.strokeStyle = "black"
    ctx.lineWidth = 2
    ctx.strokeRect(0, 0, 400, 400)

def draw_robot(x, y):
    draw_grid()
    ctx.fillStyle = "blue"
    ctx.beginPath()
    ctx.arc(x * 40 + 20, y * 40 + 20, 15, 0, 6.28)
    ctx.fill()

x, y = 0, 0
def move():
    global x
    x = (x + 1) % 10
    draw_robot(x, y)

draw_grid()
timer.set_interval(move, 500)</pre>
<p>以下程式, 按 j 隨箭頭方向前進, 按下 i 則左轉</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">from browser import document, html, bind

canvas = html.CANVAS(width=400, height=400)
brython_div = document["brython_div1"]
brython_div &lt;= canvas
ctx = canvas.getContext("2d")

cols, rows = 10, 10
cell = 40

# 上、右、下、左
directions = [(0, -1), (1, 0), (0, 1), (-1, 0)]

robot = {
    "x": 5,
    "y": 5,
    "dir": 0  # 初始朝向上
}

def draw_grid():
    ctx.clearRect(0, 0, 400, 400)
    ctx.strokeStyle = "#ccc"
    ctx.lineWidth = 1
    for i in range(0, 401, cell):
        ctx.beginPath()
        ctx.moveTo(i, 0)
        ctx.lineTo(i, 400)
        ctx.stroke()
        ctx.beginPath()
        ctx.moveTo(0, i)
        ctx.lineTo(400, i)
        ctx.stroke()
    ctx.strokeStyle = "black"
    ctx.lineWidth = 2
    ctx.strokeRect(0, 0, 400, 400)

def draw_robot():
    draw_grid()
    cx = robot["x"] * cell + cell // 2
    cy = robot["y"] * cell + cell // 2
    size = 15
    d = robot["dir"]

    ctx.fillStyle = "blue"
    ctx.beginPath()
    if d == 0:  # 上
        ctx.moveTo(cx, cy - size)
        ctx.lineTo(cx - size, cy + size)
        ctx.lineTo(cx + size, cy + size)
    elif d == 1:  # 右
        ctx.moveTo(cx + size, cy)
        ctx.lineTo(cx - size, cy - size)
        ctx.lineTo(cx - size, cy + size)
    elif d == 2:  # 下
        ctx.moveTo(cx, cy + size)
        ctx.lineTo(cx - size, cy - size)
        ctx.lineTo(cx + size, cy - size)
    elif d == 3:  # 左
        ctx.moveTo(cx - size, cy)
        ctx.lineTo(cx + size, cy - size)
        ctx.lineTo(cx + size, cy + size)
    ctx.closePath()
    ctx.fill()

@bind(document, "keydown")
def on_key(e):
    key = e.key.lower()
    if key == "i":
        robot["dir"] = (robot["dir"] - 1) % 4  # 左轉
    elif key == "j":
        dx, dy = directions[robot["dir"]]
        nx = robot["x"] + dx
        ny = robot["y"] + dy
        if 0 &lt;= nx &lt; cols and 0 &lt;= ny &lt; rows:
            robot["x"] = nx
            robot["y"] = ny
    draw_robot()

draw_robot()</pre>
<p>Optimization:</p>
<p>題目:<br/>一位製造商想設計一個開口式的盒子，其底部為長方形，寬為 x、長為 y，且總表面積為 80 平方公分。 請問要使盒子的體積達到最大，應該選用哪些尺寸？</p>
<p>直接利用 Python 以 <a href="https://en.wikipedia.org/wiki/Differential_evolution">Differential Evoluation</a> 運算: <a href="/downloads/de_volume_max.py">de_volume_max.py</a></p>
<p style="padding-left: 30px;">參考: </p>
<p style="padding-left: 60px;"><a href="/downloads/de_volume_max.c">de_volume_max.c</a></p>
<p>也可以採網頁前端使用 Brython，後端採 Python 執行運算後將資料傳回網頁: <a href="/downloads/brython_w_flask.7z">brython_w_flask.7z</a></p>
<h1>Ref</h1>
<h2>Reeborg</h2>
<p><a href="https://mde.tw/cp2025/reeborg?lang=en&amp;mode=python&amp;menu=worlds/menus/select_collection_en.json&amp;name=Alone&amp;url=worlds/tutorial_en/harvest1.json&amp;editor=python/harvest1.py">https://mde.tw/cp2025/reeborg?lang=en&amp;mode=python&amp;menu=worlds/menus/select_collection_en.json&amp;name=Alone&amp;url=worlds/tutorial_en/harvest1.json&amp;editor=python/harvest1.py</a></p>
<p><a href="https://mde.tw/cp2025/reeborg?lang=en&amp;mode=python&amp;menu=worlds/menus/select_collection_en.json&amp;name=Alone&amp;url=worlds/tutorial_en/harvest1.json&amp;editor=python/harvest1_east_west.py">https://mde.tw/cp2025/reeborg?lang=en&amp;mode=python&amp;menu=worlds/menus/select_collection_en.json&amp;name=Alone&amp;url=worlds/tutorial_en/harvest1.json&amp;editor=python/harvest1_east_west.py</a> </p>
<hr/>
<p><a href="https://mde.tw/reeborg">https://mde.tw/reeborg</a></p>
<p><a href="https://github.com/mdecycu/cs101">https://github.com/mdecycu/cs101</a></p>
<p><a href="https://reeborg.ca/docs/en/python/index.html">https://reeborg.ca/docs/en/python/index.html</a></p>
<p><a href="https://aroberge.github.io/reeborg-api/">https://aroberge.github.io/reeborg-api/</a></p>
<p>if using local static port 9442:</p>
<p style="padding-left: 30px;"><a href="https://127.0.0.1:8442/reeborg/?lang=en&amp;mode=python&amp;menu=%2Freeborg%2Fworlds%2Fmenus%2Fselect_collection_en.json&amp;name=Alone&amp;url=%2Freeborg%2Fworlds%2Ftutorial_en%2Fharvest1.json&amp;editor=%2Freeborg%2Fpython%2Fharvest1.py">Reeborg</a></p>
<p>For Github Pages:</p>
<p style="padding-left: 30px;"><a href="https://mde.tw/cp2025/reeborg?lang=en&amp;mode=python&amp;menu=%2Freeborg%2Fworlds%2Fmenus%2Fselect_collection_en.json&amp;name=Alone&amp;url=%2Freeborg%2Fworlds%2Ftutorial_en%2Fharvest1.json&amp;editor=%2Freeborg%2Fpython%2Fharvest1.py">Reeborg</a></p>
<p></p>
<h3>ex1</h3>
<p><a href="https://mde.tw/cp2025/reeborg?lang=en&amp;mode=python&amp;menu=worlds/menus/select_collection_en.json&amp;name=Alone&amp;url=worlds/tutorial_en/harvest1.json&amp;editor=python/harvest1.py">https://mde.tw/cp2025/reeborg?lang=en&amp;mode=python&amp;menu=worlds/menus/select_collection_en.json&amp;name=Alone&amp;url=worlds/tutorial_en/harvest1.json&amp;editor=python/harvest1.py</a> 是已知的機器人採收紅蘿蔔的程式，經由以下與 Copilot 的對話，希望透過 Python Class 的編寫解決特定範圍農作物採收的程式。</p>
<p>問句:</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">以下是 Reeborg 一個用來採收紅蘿蔔的程式, 目前位於 (3,3) 到 (8,8) 的區域中各座標點, 各有一個紅羅蔔等待採收, 現在想要建立一個 harvest() class, 可以利用 (3,3), (8,8)作為標定有農作物必須採收的兩個區域對角點座標, 而程式可以利用此一 harvest 類別生成案例完成採收的任務: def turn(int):
    for i in range(int):
        turn_left()
        
def new_move(int):
    for i in range(int):
        move()
        
def harvest_one_row():
    while object_here():
        take()
    else:
        move()
# move to the field
new_move(2)
turn_left()
new_move(2)

for i in range(3):
    while is_facing_north():
        for i in range(6):
            harvest_one_row()
        for i in range(2):
            turn(3)
            move() 
    else:
        for i in range(6):
            harvest_one_row()
        for i in range(2):
            turn_left()
            move()</pre>
<p>AI 回答: <a href="https://mde.tw/cp2025/reeborg?lang=en&amp;mode=python&amp;menu=worlds/menus/select_collection_en.json&amp;name=Alone&amp;url=worlds/tutorial_en/harvest1.json&amp;editor=python/harvest1_class_ex1.py">https://mde.tw/cp2025/reeborg?lang=en&amp;mode=python&amp;menu=worlds/menus/select_collection_en.json&amp;name=Alone&amp;url=worlds/tutorial_en/harvest1.json&amp;editor=python/harvest1_class_ex1.py</a> </p>
<p>進一步要求:</p>
<pre class="brush:js;auto-links:false;toolbar:false" contenteditable="false">請在類別中加上一個採收方向的參數, 內建變數是 horizontal 採收, 也就是由西邊往東邊的水平方向進行採收, 但若該方向變數設為 vertical 則會由南邊往北的所謂垂直方向進行採收</pre>
<p>AI 回應: <a href="https://mde.tw/cp2025/reeborg?lang=en&amp;mode=python&amp;menu=worlds/menus/select_collection_en.json&amp;name=Alone&amp;url=worlds/tutorial_en/harvest1.json&amp;editor=python/harvest1_class_ex2.py">https://mde.tw/cp2025/reeborg?lang=en&amp;mode=python&amp;menu=worlds/menus/select_collection_en.json&amp;name=Alone&amp;url=worlds/tutorial_en/harvest1.json&amp;editor=python/harvest1_class_ex2.py </a> </p>
<p>延伸到採收 harvest2 農田: <a href="https://mde.tw/cp2025/reeborg/?lang=en&amp;mode=python&amp;menu=worlds/menus/select_collection_en.json&amp;name=Alone&amp;url=worlds/tutorial_en/harvest2.json&amp;editor=python/harvest1_class_ex1.py">https://mde.tw/cp2025/reeborg/?lang=en&amp;mode=python&amp;menu=worlds/menus/select_collection_en.json&amp;name=Alone&amp;url=worlds/tutorial_en/harvest2.json&amp;editor=python/harvest1_class_ex1.py</a> </p>
<p>但卻沒能套用到 harvest3 農田: <a href="https://mde.tw/cp2025/reeborg/?lang=en&amp;mode=python&amp;menu=worlds/menus/select_collection_en.json&amp;name=Alone&amp;url=worlds/tutorial_en/harvest3.json&amp;editor=python/harvest1_class_ex1.py">https://mde.tw/cp2025/reeborg/?lang=en&amp;mode=python&amp;menu=worlds/menus/select_collection_en.json&amp;name=Alone&amp;url=worlds/tutorial_en/harvest3.json&amp;editor=python/harvest1_class_ex1.py</a> </p>
<p>而必須要在每一個座標點留下或放入一個紅蘿蔔: <a href="https://mde.tw/cp2025/reeborg/?lang=en&amp;mode=python&amp;menu=worlds/menus/select_collection_en.json&amp;name=Alone&amp;url=worlds/tutorial_en/harvest3.json&amp;editor=python/harvest1_class_ex3.py">https://mde.tw/cp2025/reeborg/?lang=en&amp;mode=python&amp;menu=worlds/menus/select_collection_en.json&amp;name=Alone&amp;url=worlds/tutorial_en/harvest3.json&amp;editor=python/harvest1_class_ex3.py </a> </p>
<h3>Otto_ninja</h3>
<p><a href="https://www.printables.com/model/231580-otto-ninja-starter-robot/files">https://www.printables.com/model/231580-otto-ninja-starter-robot/files</a> </p>
<p><iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="allowfullscreen" frameborder="0" height="315" referrerpolicy="strict-origin-when-cross-origin" src="https://www.youtube.com/embed/NDIwhuxQPN8?si=ED_FAObUkAVFT5L-" title="YouTube video player" width="560"></iframe></p>
<h2>Pyodide</h2>
<p><a href="https://pyodide.org">Pyodide</a> 是一個將 <a href="https://en.wikipedia.org/wiki/Python_(programming_language)">Python</a> 解譯器和常用科學套件 (例如: <a href="https://numpy.org/">numpy</a>、<a href="https://scipy.org/">scipy</a>、<a href="https://matplotlib.org/">matplotlib</a> 等) 編譯成 <a href="https://webassembly.org/">WebAssembly</a>，可在瀏覽器中執行 <a href="https://en.wikipedia.org/wiki/Python_(programming_language)">Python</a> 程式的專案。</p>
<p><a href="https://pyodide.org">Pyodide</a> 是將 <a href="https://github.com/python/cpython">CPython</a> 編譯為 <a href="https://webassembly.org/">WebAssembly</a>，可在瀏覽器或其他 <a href="https://webassembly.org/">WebAssembly</a> 環境中執行；而 <a href="https://github.com/python/cpython">CPython</a> 是標準的原生 <a href="https://en.wikipedia.org/wiki/Python_(programming_language)">Python</a> 解譯器，運行在作業系統上。換言之，<a href="https://pyodide.org">Pyodide</a> 是為在瀏覽器中執行 <a href="https://en.wikipedia.org/wiki/Python_(programming_language)">Python</a> 而設計的 <a href="https://github.com/python/cpython">CPython</a> 移植版本。<a href="https://pyodide.org">Pyodide</a> 可與 <a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript">JavaScript</a> 雙向互動，讓 <a href="https://en.wikipedia.org/wiki/Python_(programming_language)">Python</a> 程式能呼叫 <a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript">JavaScript</a> 函數並操作網頁元素，也能被 <a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript">JavaScript</a> 呼叫執行 <a href="https://en.wikipedia.org/wiki/Python_(programming_language)">Python</a> 程式碼。</p>
<p>
<script src="https://cdn.jsdelivr.net/pyodide/v0.26.4/full/pyodide.js"></script>
</p>
<p><button id="version">version</button> <button id="hello_button">hello</button> <button id="add1to100">1 add to 100</button> <button id="robot1">機器人巡邏</button><button id="free_walk">自由行</button> <button id="numpy_ode">numpy_ode</button></p>
<!-- Ace Editor Scripts -->
<p>
<script src="/static/ace/FileSaver.min.js"></script>
<script src="/static/ace/filereader.js"></script>
<script src="/static/ace/ace.js"></script>
<script src="/static/ace/ext-language_tools.js"></script>
<script src="/static/ace/mode-python.js"></script>
<script src="/static/ace/snippets/python.js"></script>
</p>
<!-- Editor 1 -->
<div id="kw_editor1" style="width: 600px; height: 300px;"></div>
<p><button id="kw_run1">Run</button> <button id="kw_output1">Output</button> <button id="kw_clear_console1">清除輸出區</button> <button onclick="location.reload()">Reload</button></p>
<p><textarea id="kw_console1"></textarea></p>
<div id="pyodide_div1"></div>
<div id="mpl_output1"></div>
<div id="brython_div1"></div>
<hr/>
<p>從 1 累加到 100 part2:</p>
<p><button id="add1to100part2">1 add to 100</button></p>
<!-- Editor 2 -->
<div id="kw_editor2" style="width: 600px; height: 300px;"></div>
<p><button id="kw_run2">Run</button> <button id="kw_output2">Output</button> <button id="kw_clear_console2">清除輸出區</button> <button onclick="location.reload()">Reload</button></p>
<p><textarea id="kw_console2"></textarea></p>
<div id="pyodide_div2"></div>
<div id="mpl_output2"></div>
<div id="brython_div2"></div>
<p>
<script>
function getUrlParam(key) {
  return new URLSearchParams(window.location.search).get(key);
}
function updateUrlParam(key, value) {
  const url = new URL(window.location);
  url.searchParams.set(key, value);
  window.history.replaceState({}, "", url);
}

let pyodide, editor1, editor2;

document.addEventListener("DOMContentLoaded", async () => {
  editor1 = ace.edit("kw_editor1");
  editor1.setTheme("ace/theme/chrome");
  editor1.session.setMode("ace/mode/python");

  editor2 = ace.edit("kw_editor2");
  editor2.setTheme("ace/theme/chrome");
  editor2.session.setMode("ace/mode/python");

  pyodide = await loadPyodide();
  await pyodide.loadPackage(["numpy", "scipy", "matplotlib", "micropip"]);

  // 定義 hello() 模組
  const code = `
def hello():
    print("Hello from custom module!")
`;
  pyodide.runPython(code);

  const GIST_ADD1TO100 =
    "https://gist.githubusercontent.com/mdecourse/0229a8a017091476a79700b8a190f185/raw/" +
    "c48e37714f055c3a0027cbfef59e442a6ef659b9/from_1_add_to_100_1.py";
  const NUMPY_ODE =
    "https://gist.githubusercontent.com/mdecycu/ec4bb35dd0769e7a83d2a9fa57878a67/raw/" +
    "98d582539545b3c9fbfa35dd3e605c506367618e/pyodide_ode_ex1.py";
  const PYODIDE_ROBOT_ANIMATION =
    "https://gist.githubusercontent.com/mdecycu/ec4bb35dd0769e7a83d2a9fa57878a67/raw/" +
    "f3d75d08f2b90f4470342e91ee1e5c36b5f950bf/pyodide_robot_ex1.py";
  const FREE_WALK = 
    "https://gist.githubusercontent.com/mdecycu/ec4bb35dd0769e7a83d2a9fa57878a67/raw/" + "d1659628afe5d36a026ef305dc639f6be4c9f608/pyodide_robot_ex3.py"

  const src = getUrlParam("src");
  if (src === PYODIDE_ROBOT_ANIMATION) {
    const robotCode = await fetchCode(PYODIDE_ROBOT_ANIMATION);
    editor1.setValue(robotCode, -1);
    updateUrlParam("src", PYODIDE_ROBOT_ANIMATION);
    runPyodide(editor1, "kw_console1", "brython_div1");
  } else {
    const initialCode = await fetchCode(src || GIST_ADD1TO100);
    editor1.setValue(initialCode, -1);
    runPyodide(editor1, "kw_console1", "brython_div1");
  }

  editor2.setValue("", -1);

  document.getElementById("version").onclick = () => {
    const vcode = `
import pyodide
import sys
import matplotlib
import numpy
import scipy
print("Pyodide version:", pyodide.__version__)
print("Python version :", sys.version)
print("matplotlib version:", matplotlib.__version__)
print("numpy version:", numpy.__version__)
print("scipy version:", scipy.__version__)
`;
    editor1.setValue(vcode, -1);
    updateUrlParam("src", "inline_version");
    runPyodide(editor1, "kw_console1", "brython_div1");
  };

  document.getElementById("hello_button").onclick = () => {
    editor1.setValue("hello()", -1);
    updateUrlParam("src", "inline_hello");
    runPyodide(editor1, "kw_console1", "brython_div1");
  };

  document.getElementById("add1to100").onclick = async () => {
    const c = await fetchCode(GIST_ADD1TO100);
    editor1.setValue(c, -1);
    updateUrlParam("src", GIST_ADD1TO100);
    runPyodide(editor1, "kw_console1", "brython_div1");
  };

  document.getElementById("numpy_ode").onclick = async () => {
    const c = await fetchCode(NUMPY_ODE);
    editor1.setValue(c, -1);
    updateUrlParam("src", NUMPY_ODE);
    runPyodide(editor1, "kw_console1", "brython_div1");
  };

  document.getElementById("robot1").onclick = async () => {
    const rc = await fetchCode(PYODIDE_ROBOT_ANIMATION);
    editor1.setValue(rc, -1);
    updateUrlParam("src", PYODIDE_ROBOT_ANIMATION);
    runPyodide(editor1, "kw_console1", "brython_div1");
  };

  document.getElementById("free_walk").onclick = async () => {
    const rc = await fetchCode(FREE_WALK);
    editor1.setValue(rc, -1);
    updateUrlParam("src", FREE_WALK);
    runPyodide(editor1, "kw_console1", "brython_div1");
  };

  document.getElementById("add1to100part2").onclick = async () => {
    const c = await fetchCode(GIST_ADD1TO100);
    editor2.setValue(c, -1);
    runPyodide(editor2, "kw_console2", "brython_div2");
  };

  document.getElementById("kw_run1").onclick = () =>
    runPyodide(editor1, "kw_console1", "brython_div1");
  document.getElementById("kw_run2").onclick = () =>
    runPyodide(editor2, "kw_console2", "brython_div2");
  document.getElementById("kw_clear_console1").onclick = () =>
    clearOutput("kw_console1", "brython_div1");
  document.getElementById("kw_clear_console2").onclick = () =>
    clearOutput("kw_console2", "brython_div2");
});

// 處理兩個 Output 列數
  document.getElementById("kw_output1").onclick = () => {
    const ta = document.getElementById("kw_console1");
    ta.rows = "15";
    ta.cols = "70";
    ta.scrollTop = 0;
  };
  document.getElementById("kw_output2").onclick = () => {
    const ta = document.getElementById("kw_console2");
    ta.rows = "15";
    ta.cols = "70";
    ta.scrollTop = 0;
  };

async function fetchCode(url) {
  const r = await fetch(url);
  if (!r.ok) throw new Error(`載入失敗 ${r.status}`);
  return await r.text();
}

function clearOutput(consoleId, divId) {
  document.getElementById(consoleId).value = "";
  document.getElementById(divId).innerHTML = "";
}

async function runPyodide(editor, consoleId, divId) {
  document.getElementById(consoleId).value = "";
  document.getElementById(divId).innerHTML = "";

  await pyodide.runPythonAsync(`
import sys
class JsWriter:
  def write(self, s):
    from js import document
    ta = document.getElementById("${consoleId}")
    ta.value += s
    ta.scrollTop = ta.scrollHeight
sys.stdout = JsWriter()
sys.stderr = JsWriter()
`);

  try {
    await pyodide.runPythonAsync(editor.getValue());
  } catch (e) {
    document.getElementById(consoleId).value += "\n錯誤：" + e.toString();
  }
}
</script>
</p>
<h2>Pyodide_ex</h2>
<p><a href="https://mde.tw/cp2025/content/Pyodide.html?src=https://gist.githubusercontent.com/mdecycu/ec4bb35dd0769e7a83d2a9fa57878a67/raw/f3d75d08f2b90f4470342e91ee1e5c36b5f950bf/pyodide_robot_ex1.py">Pyodide 機器人巡邏</a> - 由於網頁載入場景圍牆與 Pyodide 執行機器人行走模擬的速度差異，機器人巡邏畫面的圍牆無法及時顯示。</p>
<p>經過場景圍牆多次 (目前為 3 次) 載入 (必須配合瀏覽器 Client 端執行速度與網路傳輸速度進行調整)，<a href="https://mde.tw/cp2025/content/Pyodide.html?src=https%3A%2F%2Fgist.githubusercontent.com%2Fmdecycu%2Fec4bb35dd0769e7a83d2a9fa57878a67%2Fraw%2Ff3d75d08f2b90f4470342e91ee1e5c36b5f950bf%2Fpyodide_robot_ex1.py">Pyodide 機器人巡邏2</a> 可以正確載入圍牆圖檔。</p>
<p>Pyodide 導入客製化模組:</p>
<pre class="brush:js;auto-links:false;toolbar:false" contenteditable="false">const code = `
# 定義一個模組內容
def hello():
    print("Hello from custom module!")
`;
pyodide.runPython(code);
</pre>
<p><a href="https://mde.tw/cp2025/content/Pyodide.html?src=https://gist.githubusercontent.com/mdecycu/ec4bb35dd0769e7a83d2a9fa57878a67/raw/3ed6869dcd7312254513ca507de17945e15a9b6f/box_max_volume_short.py">Volume_max_pyodide_de_short.py</a></p>
<p><a href="https://mde.tw/cp2025/content/Pyodide.html?src=https://gist.githubusercontent.com/mdecycu/ec4bb35dd0769e7a83d2a9fa57878a67/raw/3ed6869dcd7312254513ca507de17945e15a9b6f/box_volume_max_pyodide_de.py">Volume_max_pyodide_de.py</a></p>
<p></p>
<h2>Pyodide2</h2>
<p>Pyodide2 在頁面中導入 <a href="https://gist.githubusercontent.com/mdecycu/ec4bb35dd0769e7a83d2a9fa57878a67/raw/ff833d14181c7e270d37432aa8589f5ecf00e383/robot.py">robot.py</a> (註解版: <a href="/downloads/pyodide_robot_commented.py">pyodide_robot_commented.py</a>) 後，可以直接在頁面編輯器中，直接利用 walk() 與 turn_left() 兩個方法，引導<a href="https://mde.tw/cp2025/content/Pyodide2.html?src=https%3A%2F%2Fgist.githubusercontent.com%2Fmdecycu%2Fec4bb35dd0769e7a83d2a9fa57878a67%2Fraw%2Fff833d14181c7e270d37432aa8589f5ecf00e383%2Fpyodide_walk_around2.py">機器人前行與左轉</a>。也可以在編輯器中自行<a href="https://mde.tw/cp2025/content/Pyodide2.html?src=https://gist.githubusercontent.com/mdecycu/ec4bb35dd0769e7a83d2a9fa57878a67/raw/8ac3ce859d6aec327b7859e091168270d6a951f7/pyodide2_turn_right.py">定義右轉方法</a>，賦予機器人更多功能。</p>
<p>
<script src="https://cdn.jsdelivr.net/pyodide/v0.26.4/full/pyodide.js"></script>
</p>
<p><button id="version">version</button> <button id="hello_button">hello</button> <button id="add1to100">1 add to 100</button> <button id="robot1">機器人巡邏</button> <button id="free_walk">自由行</button> <button id="numpy_ode">numpy_ode</button></p>
<!-- Ace Editor Scripts -->
<p>
<script src="/static/ace/FileSaver.min.js"></script>
<script src="/static/ace/filereader.js"></script>
<script src="/static/ace/ace.js"></script>
<script src="/static/ace/ext-language_tools.js"></script>
<script src="/static/ace/mode-python.js"></script>
<script src="/static/ace/snippets/python.js"></script>
</p>
<!-- Editor 1 -->
<div id="kw_editor1" style="width: 600px; height: 300px;"></div>
<p><button id="kw_run1">Run</button> <button id="kw_output1">Output</button> <button id="kw_clear_console1">清除輸出區</button> <button onclick="location.reload()">Reload</button></p>
<p><textarea id="kw_console1"></textarea></p>
<div id="pyodide_div1"></div>
<div id="mpl_output1"></div>
<div id="brython_div1"></div>
<hr/>
<p>從 1 累加到 100 part2:</p>
<p><button id="add1to100part2">1 add to 100</button></p>
<!-- Editor 2 -->
<div id="kw_editor2" style="width: 600px; height: 300px;"></div>
<p><button id="kw_run2">Run</button> <button id="kw_output2">Output</button> <button id="kw_clear_console2">清除輸出區</button> <button onclick="location.reload()">Reload</button></p>
<p><textarea id="kw_console2"></textarea></p>
<div id="pyodide_div2"></div>
<div id="mpl_output2"></div>
<div id="brython_div2"></div>
<p>
<script>
function getUrlParam(key) {
  return new URLSearchParams(window.location.search).get(key);
}
function updateUrlParam(key, value) {
  const url = new URL(window.location);
  url.searchParams.set(key, value);
  window.history.replaceState({}, "", url);
}

let pyodide, editor1, editor2;

// 新增：把 robot.py 寫入 pyodide FS
async function loadRobotModule() {
  const robotUrl = "https://gist.githubusercontent.com/mdecycu/ec4bb35dd0769e7a83d2a9fa57878a67/raw/4b94533a86b41ed8905cbb2d2bcae4e21a3e7410/robot.py";
  const r = await fetch(robotUrl);
  if (!r.ok) throw new Error(`載入 robot.py 失敗: ${r.status}`);
  const code = await r.text();
  pyodide.FS.writeFile("/robot.py", code);
  pyodide.runPython(`import sys; sys.path.append("/")`);  // 加入根目錄到 sys.path
}

document.addEventListener("DOMContentLoaded", async () => {
  editor1 = ace.edit("kw_editor1");
  editor1.setTheme("ace/theme/chrome");
  editor1.session.setMode("ace/mode/python");

  editor2 = ace.edit("kw_editor2");
  editor2.setTheme("ace/theme/chrome");
  editor2.session.setMode("ace/mode/python");

  pyodide = await loadPyodide();
  await pyodide.loadPackage(["numpy", "scipy", "matplotlib", "micropip"]);

  // 預先載入 robot.py
  await loadRobotModule();

  // 你現有的 hello() 定義
  const code = `
def hello():
    print("Hello from custom module!")
`;
  pyodide.runPython(code);

  // 這是你之前其他按鈕用的 Gist 連結
  const GIST_ADD1TO100 =
    "https://gist.githubusercontent.com/mdecourse/0229a8a017091476a79700b8a190f185/raw/" +
    "c48e37714f055c3a0027cbfef59e442a6ef659b9/from_1_add_to_100_1.py";
  const NUMPY_ODE =
    "https://gist.githubusercontent.com/mdecycu/ec4bb35dd0769e7a83d2a9fa57878a67/raw/" +
    "98d582539545b3c9fbfa35dd3e605c506367618e/pyodide_ode_ex1.py";
  const PYODIDE_ROBOT_ANIMATION =
    "https://gist.githubusercontent.com/mdecycu/ec4bb35dd0769e7a83d2a9fa57878a67/raw/" +
    "ff833d14181c7e270d37432aa8589f5ecf00e383/pyodide_walk_around2.py";
  const FREE_WALK = 
    "https://gist.githubusercontent.com/mdecycu/ec4bb35dd0769e7a83d2a9fa57878a67/raw/" + "2a66dceb4a1dbdd0c384d4d17453f1e4f03f2493/pyodide_free_walk2.py"

  // 預設載入 GIST_ADD1TO100（或 URL 參數決定）
  const src = getUrlParam("src");
  if (src === PYODIDE_ROBOT_ANIMATION) {
    const robotCode = await fetchCode(PYODIDE_ROBOT_ANIMATION);
    editor1.setValue(robotCode, -1);
    updateUrlParam("src", PYODIDE_ROBOT_ANIMATION);
    runPyodide(editor1, "kw_console1", "brython_div1");
  } else {
    const initialCode = await fetchCode(src || GIST_ADD1TO100);
    editor1.setValue(initialCode, -1);
    runPyodide(editor1, "kw_console1", "brython_div1");
  }

  editor2.setValue("", -1);

  // 按鈕事件
  document.getElementById("version").onclick = () => {
    const vcode = `
import pyodide
import sys
import matplotlib
import numpy
import scipy
print("Pyodide version:", pyodide.__version__)
print("Python version :", sys.version)
print("matplotlib version:", matplotlib.__version__)
print("numpy version:", numpy.__version__)
print("scipy version:", scipy.__version__)
`;
    editor1.setValue(vcode, -1);
    updateUrlParam("src", "inline_version");
    runPyodide(editor1, "kw_console1", "brython_div1");
  };

  document.getElementById("hello_button").onclick = () => {
    editor1.setValue("hello()", -1);
    updateUrlParam("src", "inline_hello");
    runPyodide(editor1, "kw_console1", "brython_div1");
  };

  document.getElementById("add1to100").onclick = async () => {
    const c = await fetchCode(GIST_ADD1TO100);
    editor1.setValue(c, -1);
    updateUrlParam("src", GIST_ADD1TO100);
    runPyodide(editor1, "kw_console1", "brython_div1");
  };

  document.getElementById("numpy_ode").onclick = async () => {
    const c = await fetchCode(NUMPY_ODE);
    editor1.setValue(c, -1);
    updateUrlParam("src", NUMPY_ODE);
    runPyodide(editor1, "kw_console1", "brython_div1");
  };

  document.getElementById("robot1").onclick = async () => {
    const rc = await fetchCode(PYODIDE_ROBOT_ANIMATION);
    editor1.setValue(rc, -1);
    updateUrlParam("src", PYODIDE_ROBOT_ANIMATION);
    runPyodide(editor1, "kw_console1", "brython_div1");
  };

  document.getElementById("free_walk").onclick = async () => {
    const rc = await fetchCode(FREE_WALK);
    editor1.setValue(rc, -1);
    updateUrlParam("src", FREE_WALK);
    runPyodide(editor1, "kw_console1", "brython_div1");
  };

  document.getElementById("add1to100part2").onclick = async () => {
    const c = await fetchCode(GIST_ADD1TO100);
    editor2.setValue(c, -1);
    runPyodide(editor2, "kw_console2", "brython_div2");
  };

  document.getElementById("kw_run1").onclick = () =>
    runPyodide(editor1, "kw_console1", "brython_div1");
  document.getElementById("kw_run2").onclick = () =>
    runPyodide(editor2, "kw_console2", "brython_div2");
  document.getElementById("kw_clear_console1").onclick = () =>
    clearOutput("kw_console1", "brython_div1");
  document.getElementById("kw_clear_console2").onclick = () =>
    clearOutput("kw_console2", "brython_div2");
});

// 調整 output textarea 行數
document.getElementById("kw_output1").onclick = () => {
  const ta = document.getElementById("kw_console1");
  ta.rows = "15";
  ta.cols = "70";
  ta.scrollTop = 0;
};
document.getElementById("kw_output2").onclick = () => {
  const ta = document.getElementById("kw_console2");
  ta.rows = "15";
  ta.cols = "70";
  ta.scrollTop = 0;
};

async function fetchCode(url) {
  const r = await fetch(url);
  if (!r.ok) throw new Error(`載入失敗 ${r.status}`);
  return await r.text();
}

function clearOutput(consoleId, divId) {
  document.getElementById(consoleId).value = "";
  document.getElementById(divId).innerHTML = "";
}

async function runPyodide(editor, consoleId, divId) {
  document.getElementById(consoleId).value = "";
  document.getElementById(divId).innerHTML = "";

  await pyodide.runPythonAsync(`
import sys
class JsWriter:
  def write(self, s):
    from js import document
    ta = document.getElementById("${consoleId}")
    ta.value += s
    ta.scrollTop = ta.scrollHeight
sys.stdout = JsWriter()
sys.stderr = JsWriter()
`);

  try {
    await pyodide.runPythonAsync(editor.getValue());
  } catch (e) {
    document.getElementById(consoleId).value += "\\n錯誤：" + e.toString();
  }
}
</script>
</p>
<h3>robot.py</h3>
<p><a href="https://gist.githubusercontent.com/mdecycu/ec4bb35dd0769e7a83d2a9fa57878a67/raw/ff833d14181c7e270d37432aa8589f5ecf00e383/robot.py">robot.py</a></p>
<p>第一段：模組匯入與常數定義</p>
<p>js 是 Brython 提供的 JS-Python 橋接模組，可直接操作 JavaScript DOM。<br/><br/>asyncio 是 Python 的非同步處理模組，用來讓動畫非同步進行。<br/><br/>CELL_SIZE 設定地圖中每個格子的大小（40px × 40px）。<br/><br/>WALL_THICKNESS 是用於繪製牆壁的線條厚度。<br/><br/>IMG_PATH 是儲存所有圖片的伺服器路徑（用於載入牆壁與機器人圖）。</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">import js, asyncio

# 每個格子的像素寬度
CELL_SIZE = 40

# 牆壁的厚度（像素）
WALL_THICKNESS = 6

# 圖片資源的網址前綴
IMG_PATH = "https://mde.tw/cp2025/reeborg/src/images/"
</pre>
<p>第二段：World 類別 – 建立世界與地圖圖層</p>
<p>World 類負責建立整個地圖畫面，並初始化所需的畫布圖層。<br/><br/>_image_cache 是類別層級變數，用來快取圖片物件。</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">class World:
    _image_cache = {}  # 用來暫存載入過的圖片，避免重複下載

    def __init__(self, width, height):
        self.width = width     # 地圖寬（幾格）
        self.height = height   # 地圖高（幾格）
        self.layers = self._create_layers()  # 建立四個 canvas 圖層
        self._init_html()      # 將圖層與控制按鈕加到 HTML 畫面
</pre>
<p>第三段：建立圖層</p>
<p>這些圖層都是 canvas 元素，彼此重疊在一起，依序繪製地圖。</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">    def _create_layers(self):
        return {
            "grid": js.document.createElement("canvas"),    # 網格底圖
            "walls": js.document.createElement("canvas"),   # 牆壁
            "objects": js.document.createElement("canvas"), # 痕跡/物件
            "robots": js.document.createElement("canvas"),  # 機器人
        }
</pre>
<p>第四段：初始化 HTML 結構</p>
<p>建立一個 container 容器，設定為相對定位。<br/><br/>將四層 canvas 疊放進容器中，每層用不同的 zIndex 疊層排序。</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">    def _init_html(self):
        container = js.document.createElement("div")
        container.style.position = "relative"
        container.style.width = f"{self.width * CELL_SIZE}px"
        container.style.height = f"{self.height * CELL_SIZE}px"

        for z, canvas in enumerate(self.layers.values()):
            canvas.width = self.width * CELL_SIZE
            canvas.height = self.height * CELL_SIZE
            canvas.style.position = "absolute"
            canvas.style.top = "0px"
            canvas.style.left = "0px"
            canvas.style.zIndex = str(z)
            container.appendChild(canvas)
</pre>
<p>第五段：建立控制按鈕並加入畫面</p>
<p>建立兩個按鈕：「前進」與「左轉」。<br/><br/>設定美觀的樣式（內邊距、字體大小等）。</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">        button_container = js.document.createElement("div")
        button_container.style.marginTop = "10px"
        button_container.style.textAlign = "center"

        move_button = js.document.createElement("button")
        move_button.innerHTML = "Move Forward"
        move_button.style.margin = "5px"
        move_button.style.padding = "10px 20px"
        move_button.style.fontSize = "16px"
        button_container.appendChild(move_button)

        turn_button = js.document.createElement("button")
        turn_button.innerHTML = "Turn Left"
        turn_button.style.margin = "5px"
        turn_button.style.padding = "10px 20px"
        turn_button.style.fontSize = "16px"
        button_container.appendChild(turn_button)
</pre>
<p> 第六段：掛載進 HTML 與按鈕綁定</p>
<p>將畫面掛載到 HTML 中的 brython_div1 元素內。<br/><br/>同時記錄兩個按鈕到 self.move_button、self.turn_button 屬性，以便之後綁定事件</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">        brython_div = js.document.getElementById("brython_div1")
        if not brython_div:
            raise RuntimeError("🚨 'brython_div1' element not found in HTML!")
        brython_div.innerHTML = ""
        brython_div.appendChild(container)
        brython_div.appendChild(button_container)

        self.move_button = move_button
        self.turn_button = turn_button
</pre>
<p>第七段：繪製地圖網格線（grid）</p>
<p>這段程式會畫出地圖的格線，形成棋盤狀的網格。<br/><br/>每格大小為 CELL_SIZE = 40 像素。<br/><br/>格線只是視覺輔助，沒有碰撞作用。</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">    def _draw_grid(self):
        ctx = self.layers["grid"].getContext("2d")  # 取得網格圖層的繪圖上下文
        ctx.strokeStyle = "#cccccc"  # 設定線條顏色為淡灰色

        # 垂直線（每列格線）
        for i in range(self.width + 1):
            ctx.beginPath()
            ctx.moveTo(i * CELL_SIZE, 0)
            ctx.lineTo(i * CELL_SIZE, self.height * CELL_SIZE)
            ctx.stroke()

        # 水平線（每欄格線）
        for j in range(self.height + 1):
            ctx.beginPath()
            ctx.moveTo(0, j * CELL_SIZE)
            ctx.lineTo(self.width * CELL_SIZE, j * CELL_SIZE)
            ctx.stroke()
</pre>
<p>第八段：通用繪圖函式 _draw_image()</p>
<p>此函式負責畫圖片在指定格子位置。<br/><br/>需要傳入：<br/><br/>    ctx: 要繪製的畫布上下文。<br/><br/>    img_key: 要畫的圖片鍵（例如 "blue_robot_e"）。<br/><br/>    (x, y): 要畫在哪個格子（以地圖邏輯座標為主）。<br/><br/>    (w, h): 圖片的寬與高。<br/><br/>會自動調整畫面位置，將 y 軸上下反轉，使原點在左下角。</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">    def _draw_image(self, ctx, img_key, x, y, w, h, offset_x=0, offset_y=0):
        img = World._image_cache.get(img_key)
        if img and img.complete and img.naturalWidth &gt; 0:
            px = x * CELL_SIZE + offset_x
            py = (self.height - 1 - y) * CELL_SIZE + offset_y
            ctx.drawImage(img, px, py, w, h)
            return True
        else:
            print(f"⚠️ Image '{img_key}' not ready for drawing.")
            return False
</pre>
<p>第九段：繪製牆壁 _draw_walls()</p>
<p>這段會將四周的「邊界牆」畫出來。<br/><br/>利用 _draw_image 畫出 north.png 與 east.png。<br/><br/>offset_x / offset_y 用來對齊圖片位置（不會蓋到格子內）。</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">    async def _draw_walls(self):
        ctx = self.layers["walls"].getContext("2d")
        ctx.clearRect(0, 0, self.width * CELL_SIZE, self.height * CELL_SIZE)
        success = True

        # 繪製上下兩排的北牆（頂部與底部）
        for x in range(self.width):
            success &amp;= self._draw_image(ctx, "north", x, self.height - 1, CELL_SIZE, WALL_THICKNESS, offset_y=0)
            success &amp;= self._draw_image(ctx, "north", x, 0, CELL_SIZE, WALL_THICKNESS, offset_y=CELL_SIZE - WALL_THICKNESS)

        # 繪製左右兩側的東牆（左邊與右邊）
        for y in range(self.height):
            success &amp;= self._draw_image(ctx, "east", 0, y, WALL_THICKNESS, CELL_SIZE, offset_x=0)
            success &amp;= self._draw_image(ctx, "east", self.width - 1, y, WALL_THICKNESS, CELL_SIZE, offset_x=CELL_SIZE - WALL_THICKNESS)

        return success
</pre>
<p>第十段：預先載入圖片 _preload_images()</p>
<p>此函式會載入所有需要用到的圖片（牆壁與機器人朝向圖）。<br/><br/>利用 Promise 建立圖片載入完成的非同步事件，確保載入成功。<br/><br/>透過 await js.await_promise(js.Promise.all(...)) 等待所有圖片載入完畢。</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">    async def _preload_images(self):
        image_files = {
            "blue_robot_e": "blue_robot_e.png",
            "blue_robot_n": "blue_robot_n.png",
            "blue_robot_w": "blue_robot_w.png",
            "blue_robot_s": "blue_robot_s.png",
            "north": "north.png",
            "east": "east.png",
        }

        promises = []
        for key, filename in image_files.items():
            if key in World._image_cache and World._image_cache[key].complete:
                continue

            img = js.document.createElement("img")
            img.crossOrigin = "Anonymous"
            img.src = IMG_PATH + filename
            World._image_cache[key] = img

            def make_promise(img_element):
                def executor(resolve, reject):
                    def on_load(event):
                        img_element.removeEventListener("load", on_load)
                        img_element.removeEventListener("error", on_error)
                        resolve(img_element)
                    def on_error(event):
                        img_element.removeEventListener("load", on_load)
                        img_element.removeEventListener("error", on_error)
                        reject(f"Failed to load image: {img_element.src}")
                    img_element.addEventListener("load", on_load)
                    img_element.addEventListener("error", on_error)
                    if img_element.complete and img_element.naturalWidth &gt; 0:
                        resolve(img_element)
                return js.Promise.new(executor)

            promises.append(make_promise(img))

        if not promises:
            return True
        try:
            await js.await_promise(js.Promise.all(promises))
            return True
        except Exception as e:
            print(f"🚨 Error during image preloading: {str(e)}")
            return False
</pre>
<p>第十一段：初始化地圖與資源 setup()</p>
<p>setup() 是建構完世界後必須呼叫的初始化函式。<br/><br/>包含資源載入、地圖格線與牆壁的繪製。<br/><br/>使用 asyncio.sleep(0) 是一種「讓出主控權給瀏覽器」的技巧，避免卡住畫面。</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">    async def setup(self):
        # 嘗試三次載入圖片資源，若載入成功則跳出迴圈
        for _ in range(3):
            if await self._preload_images():
                break
            await asyncio.sleep(0.5)  # 等待 0.5 秒後再試
        else:
            print("🚨 Failed to preload images after retries.")
            return False

        await asyncio.sleep(0)  # 放棄當前事件迴圈執行權，確保 UI 有機會更新

        self._draw_grid()  # 繪製底層的網格

        # 嘗試三次繪製牆壁，等待圖片載入完成
        for _ in range(3):
            if await self._draw_walls():
                break
            await asyncio.sleep(0.5)
        else:
            print("🚨 Failed to draw walls after retries.")
            return False

        # 最後確認機器人朝向東的圖片是否可用
        robot_img_key = "blue_robot_e"
        if not (World._image_cache.get(robot_img_key) and World._image_cache[robot_img_key].complete):
            print(f"🚨 Robot image '{robot_img_key}' still not ready after setup!")
            return False

        return True  # 所有步驟成功後回傳 True
</pre>
<p>第十二段：機器人類別 Robot</p>
<p>每個 Robot 物件都有座標與面向，並能畫出自己與移動的軌跡。<br/><br/>傳入 world 是為了能取得地圖的畫布資訊。</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">class Robot:
    def __init__(self, world, x, y):
        self.world = world
        self.x = x - 1  # 將人類習慣的 1-index 轉成 0-index
        self.y = y - 1
        self.facing = "E"  # 預設朝東（右邊）
        self._facing_order = ["E", "N", "W", "S"]  # 左轉時的順序

        self.robot_ctx = world.layers["robots"].getContext("2d")   # 機器人圖層
        self.trace_ctx = world.layers["objects"].getContext("2d")  # 移動軌跡圖層

        self._draw_robot()  # 初始畫上機器人
</pre>
<p>_robot_image_key()：依面向回傳圖片鍵</p>
<p>根據面向回傳對應的圖片鍵，例如 <code data-end="1939" data-start="1936">E</code> 會回傳 <code data-end="1960" data-start="1944">"blue_robot_e"</code>。</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">    def _robot_image_key(self):
        return f"blue_robot_{self.facing.lower()}"
</pre>
<p>_draw_robot()：畫出機器人圖像</p>
<p>先清除原圖，避免留下殘影，再畫上新的機器人圖像。</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">    def _draw_robot(self):
        self.robot_ctx.clearRect(0, 0, self.world.width * CELL_SIZE, self.world.height * CELL_SIZE)
        self.world._draw_image(self.robot_ctx, self._robot_image_key(), self.x, self.y, CELL_SIZE, CELL_SIZE)
</pre>
<p>_draw_trace()：畫出移動路徑</p>
<p>此方法畫出機器人從起點到終點的直線軌跡。</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">    def _draw_trace(self, from_x, from_y, to_x, to_y):
        ctx = self.trace_ctx
        ctx.strokeStyle = "#d33"  # 紅色線條
        ctx.lineWidth = 2
        ctx.beginPath()
        fx = from_x * CELL_SIZE + CELL_SIZE / 2
        fy = (self.world.height - 1 - from_y) * CELL_SIZE + CELL_SIZE / 2
        tx = to_x * CELL_SIZE + CELL_SIZE / 2
        ty = (self.world.height - 1 - to_y) * CELL_SIZE + CELL_SIZE / 2
        ctx.moveTo(fx, fy)
        ctx.lineTo(tx, ty)
        ctx.stroke()
</pre>
<p>第十三段：機器人行走與轉彎</p>
<p>walk(steps)：前進</p>
<p>根據面向方向更新位置，並畫出移動。<br/><br/>超出地圖邊界時停止。</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">    async def walk(self, steps=1):
        for _ in range(steps):
            from_x, from_y = self.x, self.y
            dx, dy = 0, 0
            if self.facing == "E": dx = 1
            elif self.facing == "W": dx = -1
            elif self.facing == "N": dy = 1
            elif self.facing == "S": dy = -1

            next_x = self.x + dx
            next_y = self.y + dy

            if 0 &lt;= next_x &lt; self.world.width and 0 &lt;= next_y &lt; self.world.height:
                self.x, self.y = next_x, next_y
                self._draw_trace(from_x, from_y, self.x, self.y)
                self._draw_robot()
                await asyncio.sleep(0.2)
            else:
                print("🚨 Hit a wall, stop moving!")
                break
</pre>
<p>turn_left()：左轉</p>
<p>從目前面向向左轉一格，更新圖片。</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">    async def turn_left(self):
        idx = self._facing_order.index(self.facing)
        self.facing = self._facing_order[(idx + 1) % 4]  # 循環轉向
        self._draw_robot()
        await asyncio.sleep(0.3)
</pre>
<p>第十四段：綁定控制 _bind_controls(robot)</p>
<p>定義一個私有方法，將控制行為綁定給特定 robot 實例。</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">def _bind_controls(robot: Robot):
</pre>
<p>鍵盤控制</p>
<p>設定 j → 前進，i → 左轉。<br/><br/>使用 asyncio.create_task() 以非同步方式執行，避免卡住主執行緒。</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">    def handle_key(event):
        try:
            if event.key == 'j':
                asyncio.create_task(robot.walk(1))     # 按下 j 移動一步
            elif event.key == 'i':
                asyncio.create_task(robot.turn_left()) # 按下 i 左轉
        except Exception as e:
            print(f"🚨 Error in key handler: {e}")
</pre>
<p>按鈕點擊控制</p>
<p>這兩個函式綁定到 UI 裡的按鈕（前面 _init_html() 中定義的）。<br/><br/>功能與鍵盤控制一樣，只是透過滑鼠點擊。</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">    def handle_move_button(event):
        try:
            asyncio.create_task(robot.walk(1))
        except Exception as e:
            print(f"🚨 Error in move button handler: {e}")

    def handle_turn_button(event):
        try:
            asyncio.create_task(robot.turn_left())
        except Exception as e:
            print(f"🚨 Error in turn button handler: {e}")
</pre>
<p>註冊事件到 JavaScript</p>
<p>將 handle_key() 註冊為全域 py_handle_key，讓 JavaScript 層級可以呼叫 Python。</p>
<p>將按鈕的點擊事件對應到 Python 定義的控制函式。</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">    js.window.py_handle_key = handle_key
    js.document.addEventListener('keydown', js.Function("event", "py_handle_key(event);"))
    js.window.py_handle_move_button = handle_move_button
    js.window.py_handle_turn_button = handle_turn_button
    robot.world.move_button.addEventListener('click', js.Function("event", "py_handle_move_button(event);"))
    robot.world.turn_button.addEventListener('click', js.Function("event", "py_handle_turn_button(event);"))</pre>
<p>第十五段：初始化並啟動 init()</p>
<p>提供一個使用者簡單快速初始化整個世界與機器人的介面。</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">def init(world_width=10, world_height=10, robot_x=1, robot_y=1):
</pre>
<p>包裝為非同步任務</p>
<p>這個包裝函式 async def _inner() 是用來實作內部非同步邏輯。</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">    async def _inner():
        world = World(world_width, world_height)  # 建立世界
        if not await world.setup():               # 等待世界初始化完成
            raise RuntimeError("World setup failed!")  # 若失敗則丟出錯誤

        robot = Robot(world, robot_x, robot_y)    # 建立機器人
        _bind_controls(robot)                     # 綁定控制事件
        return world, robot                       # 傳回 world 和 robot 物件
</pre>
<p>建立並啟動非同步任務</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">    return asyncio.create_task(_inner())
</pre>
<p>回傳一個非同步任務（asyncio.Task），讓使用者可以這樣呼叫：</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">world, robot = await init(10, 10, 1, 1)
</pre>
<p>等待 init() 的結果後，就可以直接控制 robot.walk() 或 robot.turn_left()。</p>
<h3>Example2</h3>
<p>自行定義機器人右轉的非同步執行函式:</p>
<p><a href="https://mde.tw/cp2025/content/Pyodide2.html?src=https://gist.githubusercontent.com/mdecycu/ec4bb35dd0769e7a83d2a9fa57878a67/raw/8ac3ce859d6aec327b7859e091168270d6a951f7/pyodide2_turn_right.py">執行 turn_right 程式</a>範例。</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">import robot
import asyncio

# 定義右轉的非同步函式
async def turn_right(bot):
    for _ in range(3):
        await bot.turn_left()

async def main():
    world, bot = await robot.init(10, 10, 1, 1)
    print("機器人開始行動")
    await bot.turn_left()
    await bot.walk(9)
    await turn_right(bot) 
    print("機器人完成行動")

# main() 讓出執行控制權，由頁面中的 even loop 決定何時執行 main()
await main()
</pre>
<h2>Pyodide3</h2>
<p>Pyodide3 則在 <a href="https://mde.tw/cp2025/content/Pyodide.html">Pyodide</a> 與 <a href="https://mde.tw/cp2025/content/Pyodide2.html">Pyodide2</a> 頁面架構下，進一步導入 <a href="https://gist.githubusercontent.com/mdecycu/ec4bb35dd0769e7a83d2a9fa57878a67/raw/9f43571ec070ea3e24b083525ee27275a96efcc8/robot_w_world.py">robot_w_world.py</a>，在既有的水平圍牆 <a href="https://mde.tw/cp2025/reeborg/src/images/north.png">north.png</a> 與垂直圍牆 <a href="https://mde.tw/cp2025/reeborg/src/images/east.png">east.png</a> 檔案之外，加入 <a href="https://mde.tw/cp2025/reeborg/src/images/carrot.png">carrot.png</a>、<a href="https://mde.tw/cp2025/reeborg/src/images/grass.png">grass.png</a> 與 <a href="https://mde.tw/cp2025/reeborg/src/images/pale_grass.png">pale_grass.png</a> 等圖檔。並且擴充可從 URL 讀進 json 格式的 world 變數功能，以便製作出更多元的場景任務，要求機器人執行。</p>
<p>其中 src URL 變數，可以將網路上的機器人控制程式導入 Pyodide3 頁面外，world URL 變數則可以導入源自 <a href="https://mde.tw/reeborg">Reeborg</a> 機器人程式所設定的 json 格式場景。</p>
<p>由於 Reeborg 系統中的 png 圖檔均非透明背景，<a href="https://gist.githubusercontent.com/mdecycu/ec4bb35dd0769e7a83d2a9fa57878a67/raw/9f43571ec070ea3e24b083525ee27275a96efcc8/robot_w_world.py">robot_w_world.py</a> 必須利用 HTML 中的 CANVAS，將關鍵的白色背景，以透明的方式顯示。</p>
<p>src URL 變數讀進 <a href="https://gist.githubusercontent.com/mdecycu/ec4bb35dd0769e7a83d2a9fa57878a67/raw/8ac3ce859d6aec327b7859e091168270d6a951f7/pyodide2_turn_right.py">turn_right 程式</a>，而 world URL 變數則讀進 <a href="https://gist.githubusercontent.com/mdecycu/ec4bb35dd0769e7a83d2a9fa57878a67/raw/43517f3f54a5ac24d55d5a5cf8d316e6db2f3b65/harvest2.json">harvest2.json</a>，執行<a href="https://mde.tw/cp2025/content/Pyodide3.html?src=https://gist.githubusercontent.com/mdecycu/ec4bb35dd0769e7a83d2a9fa57878a67/raw/8ac3ce859d6aec327b7859e091168270d6a951f7/pyodide2_turn_right.py&amp;world=https://gist.githubusercontent.com/mdecycu/ec4bb35dd0769e7a83d2a9fa57878a67/raw/43517f3f54a5ac24d55d5a5cf8d316e6db2f3b65/harvest2.json">結果</a>。</p>
<p>讀進 <a href="https://gist.githubusercontent.com/mdecycu/ec4bb35dd0769e7a83d2a9fa57878a67/raw/1b1c26eca7f5d772c6301bae865efaddb00a87bb/harvest3.json">harvest3.json</a>, 執行<a href="https://mde.tw/cp2025/content/Pyodide3.html?src=https://gist.githubusercontent.com/mdecycu/ec4bb35dd0769e7a83d2a9fa57878a67/raw/8ac3ce859d6aec327b7859e091168270d6a951f7/pyodide2_turn_right.py&amp;world=https://gist.githubusercontent.com/mdecycu/ec4bb35dd0769e7a83d2a9fa57878a67/raw/9f43571ec070ea3e24b083525ee27275a96efcc8/harvest3.json">結果</a>。</p>
<p>
<script src="https://cdn.jsdelivr.net/pyodide/v0.26.4/full/pyodide.js"></script>
</p>
<p><button id="version">version</button> <button id="hello_button">hello</button> <button id="add1to100">1 add to 100</button> <button id="robot1">機器人巡邏</button> <button id="free_walk">自由行</button> <button id="numpy_ode">numpy_ode</button></p>
<!-- Ace Editor Scripts -->
<p>
<script src="/static/ace/FileSaver.min.js"></script>
<script src="/static/ace/filereader.js"></script>
<script src="/static/ace/ace.js"></script>
<script src="/static/ace/ext-language_tools.js"></script>
<script src="/static/ace/mode-python.js"></script>
<script src="/static/ace/snippets/python.js"></script>
</p>
<!-- Editor 1 -->
<div id="kw_editor1" style="width: 600px; height: 300px;"></div>
<p><button id="kw_run1">Run</button> <button id="kw_output1">Output</button> <button id="kw_clear_console1">清除輸出區</button> <button onclick="location.reload()">Reload</button></p>
<p><textarea id="kw_console1"></textarea></p>
<div id="pyodide_div1"></div>
<div id="mpl_output1"></div>
<div id="brython_div1"></div>
<hr/>
<p>從 1 累加到 100 part2:</p>
<p><button id="add1to100part2">1 add to 100</button></p>
<!-- Editor 2 -->
<div id="kw_editor2" style="width: 600px; height: 300px;"></div>
<p><button id="kw_run2">Run</button> <button id="kw_output2">Output</button> <button id="kw_clear_console2">清除輸出區</button> <button onclick="location.reload()">Reload</button></p>
<p><textarea id="kw_console2"></textarea></p>
<div id="pyodide_div2"></div>
<div id="mpl_output2"></div>
<div id="brython_div2"></div>
<p>
<script>
function getUrlParam(key) {
  return new URLSearchParams(window.location.search).get(key);
}
function updateUrlParam(key, value) {
  const url = new URL(window.location);
  url.searchParams.set(key, value);
  window.history.replaceState({}, "", url);
}

let pyodide, editor1, editor2;

// 新增：把 robot_w_world.py 寫入 pyodide FS
async function loadRobotModule() {
  const robotUrl = "https://gist.githubusercontent.com/mdecycu/ec4bb35dd0769e7a83d2a9fa57878a67/raw/9f43571ec070ea3e24b083525ee27275a96efcc8/robot_w_world.py";
  const r = await fetch(robotUrl);
  if (!r.ok) throw new Error(`載入 robot.py 失敗: ${r.status}`);
  const code = await r.text();
  pyodide.FS.writeFile("/robot.py", code);
  pyodide.runPython(`import sys; sys.path.append("/")`);  // 加入根目錄到 sys.path
}

document.addEventListener("DOMContentLoaded", async () => {
  editor1 = ace.edit("kw_editor1");
  editor1.setTheme("ace/theme/chrome");
  editor1.session.setMode("ace/mode/python");

  editor2 = ace.edit("kw_editor2");
  editor2.setTheme("ace/theme/chrome");
  editor2.session.setMode("ace/mode/python");

  pyodide = await loadPyodide();
  await pyodide.loadPackage(["numpy", "scipy", "matplotlib", "micropip"]);

  // 預先載入 robot.py
  await loadRobotModule();

  // 你現有的 hello() 定義
  const code = `
def hello():
    print("Hello from custom module!")
`;
  pyodide.runPython(code);

  // 這是你之前其他按鈕用的 Gist 連結
  const GIST_ADD1TO100 =
    "https://gist.githubusercontent.com/mdecourse/0229a8a017091476a79700b8a190f185/raw/" +
    "c48e37714f055c3a0027cbfef59e442a6ef659b9/from_1_add_to_100_1.py";
  const NUMPY_ODE =
    "https://gist.githubusercontent.com/mdecycu/ec4bb35dd0769e7a83d2a9fa57878a67/raw/" +
    "98d582539545b3c9fbfa35dd3e605c506367618e/pyodide_ode_ex1.py";
  const PYODIDE_ROBOT_ANIMATION =
    "https://gist.githubusercontent.com/mdecycu/ec4bb35dd0769e7a83d2a9fa57878a67/raw/" +
    "ff833d14181c7e270d37432aa8589f5ecf00e383/pyodide_walk_around2.py";
  const FREE_WALK = 
    "https://gist.githubusercontent.com/mdecycu/ec4bb35dd0769e7a83d2a9fa57878a67/raw/" + "2a66dceb4a1dbdd0c384d4d17453f1e4f03f2493/pyodide_free_walk2.py"

  // 預設載入 GIST_ADD1TO100（或 URL 參數決定）
  const src = getUrlParam("src");
  if (src === PYODIDE_ROBOT_ANIMATION) {
    const robotCode = await fetchCode(PYODIDE_ROBOT_ANIMATION);
    editor1.setValue(robotCode, -1);
    updateUrlParam("src", PYODIDE_ROBOT_ANIMATION);
    runPyodide(editor1, "kw_console1", "brython_div1");
  } else {
    const initialCode = await fetchCode(src || GIST_ADD1TO100);
    editor1.setValue(initialCode, -1);
    runPyodide(editor1, "kw_console1", "brython_div1");
  }

  editor2.setValue("", -1);

  // 按鈕事件
  document.getElementById("version").onclick = () => {
    const vcode = `
import pyodide
import sys
import matplotlib
import numpy
import scipy
print("Pyodide version:", pyodide.__version__)
print("Python version :", sys.version)
print("matplotlib version:", matplotlib.__version__)
print("numpy version:", numpy.__version__)
print("scipy version:", scipy.__version__)
`;
    editor1.setValue(vcode, -1);
    updateUrlParam("src", "inline_version");
    runPyodide(editor1, "kw_console1", "brython_div1");
  };

  document.getElementById("hello_button").onclick = () => {
    editor1.setValue("hello()", -1);
    updateUrlParam("src", "inline_hello");
    runPyodide(editor1, "kw_console1", "brython_div1");
  };

  document.getElementById("add1to100").onclick = async () => {
    const c = await fetchCode(GIST_ADD1TO100);
    editor1.setValue(c, -1);
    updateUrlParam("src", GIST_ADD1TO100);
    runPyodide(editor1, "kw_console1", "brython_div1");
  };

  document.getElementById("numpy_ode").onclick = async () => {
    const c = await fetchCode(NUMPY_ODE);
    editor1.setValue(c, -1);
    updateUrlParam("src", NUMPY_ODE);
    runPyodide(editor1, "kw_console1", "brython_div1");
  };

  document.getElementById("robot1").onclick = async () => {
    const rc = await fetchCode(PYODIDE_ROBOT_ANIMATION);
    editor1.setValue(rc, -1);
    updateUrlParam("src", PYODIDE_ROBOT_ANIMATION);
    runPyodide(editor1, "kw_console1", "brython_div1");
  };

  document.getElementById("free_walk").onclick = async () => {
    const rc = await fetchCode(FREE_WALK);
    editor1.setValue(rc, -1);
    updateUrlParam("src", FREE_WALK);
    runPyodide(editor1, "kw_console1", "brython_div1");
  };

  document.getElementById("add1to100part2").onclick = async () => {
    const c = await fetchCode(GIST_ADD1TO100);
    editor2.setValue(c, -1);
    runPyodide(editor2, "kw_console2", "brython_div2");
  };

  document.getElementById("kw_run1").onclick = () =>
    runPyodide(editor1, "kw_console1", "brython_div1");
  document.getElementById("kw_run2").onclick = () =>
    runPyodide(editor2, "kw_console2", "brython_div2");
  document.getElementById("kw_clear_console1").onclick = () =>
    clearOutput("kw_console1", "brython_div1");
  document.getElementById("kw_clear_console2").onclick = () =>
    clearOutput("kw_console2", "brython_div2");
});

// 調整 output textarea 行數
document.getElementById("kw_output1").onclick = () => {
  const ta = document.getElementById("kw_console1");
  ta.rows = "15";
  ta.cols = "70";
  ta.scrollTop = 0;
};
document.getElementById("kw_output2").onclick = () => {
  const ta = document.getElementById("kw_console2");
  ta.rows = "15";
  ta.cols = "70";
  ta.scrollTop = 0;
};

async function fetchCode(url) {
  const r = await fetch(url);
  if (!r.ok) throw new Error(`載入失敗 ${r.status}`);
  return await r.text();
}

function clearOutput(consoleId, divId) {
  document.getElementById(consoleId).value = "";
  document.getElementById(divId).innerHTML = "";
}

async function runPyodide(editor, consoleId, divId) {
  document.getElementById(consoleId).value = "";
  document.getElementById(divId).innerHTML = "";

  await pyodide.runPythonAsync(`
import sys
class JsWriter:
  def write(self, s):
    from js import document
    ta = document.getElementById("${consoleId}")
    ta.value += s
    ta.scrollTop = ta.scrollHeight
sys.stdout = JsWriter()
sys.stderr = JsWriter()
`);

  try {
    await pyodide.runPythonAsync(editor.getValue());
  } catch (e) {
    document.getElementById(consoleId).value += "\\n錯誤：" + e.toString();
  }
}
</script>
</p>
<h3>png_files</h3>
<p>利用 <a href="https://gist.githubusercontent.com/mdecycu/ec4bb35dd0769e7a83d2a9fa57878a67/raw/9f43571ec070ea3e24b083525ee27275a96efcc8/robot_w_world.py">robot_w_world.py</a> 將 png 圖檔實踐「關鍵色透明」:<br/><br/>作法是在程式碼中額外添加像素處理的邏輯。Canvas 的 drawImage 方法本身不會自動識別並跳過特定顏色的像素，所以我們必須手動介入。<br/><br/>處理方法:<br/><br/>要讓 <a href="https://gist.githubusercontent.com/mdecycu/ec4bb35dd0769e7a83d2a9fa57878a67/raw/9f43571ec070ea3e24b083525ee27275a96efcc8/robot_w_world.py">robot_w_world.py</a> 實現這個功能，必須修改 _draw_image 方法，或者在圖片載入後進行預處理。最直接的方法是在繪製數字圖片時，讀取其像素數據，並將特定顏色（例如白色）的像素的 Alpha 值設置為 0。<br/><br/>這會涉及以下步驟：<br/><br/>    取得圖片像素資料： 將圖片繪製到一個臨時的、看不見的 Canvas 上。<br/><br/>    讀進所有像素： 讀取這個臨時 Canvas 的像素資料。<br/><br/>    修改像素的 Alpha 值： 檢查每個像素的 RGB 值，如果它符合預設的「關鍵色」（例如，純白色 (255, 255, 255)），就將其 Alpha (透明度) 值設為 0。<br/><br/>    將修改後的像素資料放回： 將修改後的像素資料重新放回臨時 Canvas。<br/><br/>    繪製臨時 Canvas： 最後，將這個處理過的臨時 Canvas 繪製到我們實際要顯示的圖層上。<br/><br/>缺點與考量:<br/><br/>    性能影響： 像素級的處理是相對耗費資源的，特別是當有很多數字需要顯示時。這可能會導致動畫或初始加載時出現輕微的延遲。<br/><br/>    複雜性增加： 程式碼會變得更複雜，需要處理 Canvas API 的 getImageData 和 putImageData 方法。<br/><br/>    關鍵色選擇： 您需要確定一個所有數字圖片背景都一致的「關鍵色」。如果有些數字圖片背景是白色，有些是淺灰色，這個方法就會失效。</p>
<h3>Harvest</h3>
<p><a href="https://mde.tw/cp2025/content/Pyodide3.html">Pyodide3</a> 在頁面中導入 <a href="https://gist.githubusercontent.com/mdecycu/ec4bb35dd0769e7a83d2a9fa57878a67/raw/9f43571ec070ea3e24b083525ee27275a96efcc8/robot_w_world.py">robot_w_world.py</a> 後，可以透過 <a href="https://gist.githubusercontent.com/mdecycu/ec4bb35dd0769e7a83d2a9fa57878a67/raw/a1de47ae2a2c941d6abe945bd58ae79ba38be8c6/pyodide3_harvest_ex1.py">pyodide3_harvest_ex1.py</a> 繼承 robot 物件，加入農作物採收功能。</p>
<p>但因為 <a href="https://gist.githubusercontent.com/mdecycu/ec4bb35dd0769e7a83d2a9fa57878a67/raw/9f43571ec070ea3e24b083525ee27275a96efcc8/robot_w_world.py">robot_w_world.py</a> 版本中的 trace 繪製圖層並未獨立，除了採收農作物之後的座標背景會從 pale_grass.png 置換為 grass.png 外，農作物採收後的座標畫面刷新會一併將之前的機器人行走路徑刪除，因此後續版本必須將所有不同屬性的圖像，以各自的獨立圖層進行繪製，才不會互相影響下，產生錯誤的機器人農作物採收模擬。</p>
<p>在 Pyodide3 執行 <a href="/downloads/pyodide3_harvest_ex1.py">pyodide3_harvest_ex1.py</a>，執行<a href="https://mde.tw/cp2025/content/Pyodide3.html?src=https://gist.githubusercontent.com/mdecycu/ec4bb35dd0769e7a83d2a9fa57878a67/raw/f1663c2de7f7f7a7fe24723c196810642865822f/pyodide3_harvest_ex1.py&amp;world=https://gist.githubusercontent.com/mdecycu/ec4bb35dd0769e7a83d2a9fa57878a67/raw/9f43571ec070ea3e24b083525ee27275a96efcc8/harvest3.json">結果</a>。</p>
<p></p>